  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zxblog.eu.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java工程师面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="Java工程师面试题-中间件-消息队列">
<meta property="og:url" content="https://zxblog.eu.org/posts/a810/index.html">
<meta property="og:site_name" content="知行博客">
<meta property="og:description" content="Java工程师面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zxblog.eu.org/assets/KMn14QrRDiywx7u.webp">
<meta property="og:image" content="https://zxblog.eu.org/assets/LWa5Ghmdi2kMAPp.webp">
<meta property="og:image" content="https://zxblog.eu.org/assets/FRueWC4bojvs3Zi.png">
<meta property="og:image" content="https://zxblog.eu.org/assets/jJ9PTo3sfbwY1rD.png">
<meta property="og:image" content="https://zxblog.eu.org/assets/7ykoE5NSZ8FVc6b.png">
<meta property="og:image" content="https://zxblog.eu.org/assets/7r58unDshyOo46L.png">
<meta property="article:published_time" content="2022-08-16T08:47:11.000Z">
<meta property="article:modified_time" content="2024-08-18T10:14:29.251Z">
<meta property="article:author" content="zhangxin">
<meta property="article:tag" content="Java工程师面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zxblog.eu.org/assets/KMn14QrRDiywx7u.webp">


<link rel="canonical" href="https://zxblog.eu.org/posts/a810/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zxblog.eu.org/posts/a810/","path":"posts/a810/","title":"Java工程师面试题-中间件-消息队列"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java工程师面试题-中间件-消息队列 | 知行博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">知行博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">新站点：zxalive.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">MQ有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">说一说生产者与消费者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">消息队列如何保证顺序消费？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">消息队列如何保证消息不丢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">消息队列如何保证不重复消费？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E5%A4%B1%E8%B4%A5%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">MQ处理消息失败了怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E4%BB%8B%E7%BB%8D%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A8%E5%92%8C%E6%8B%89%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.</span> <span class="nav-text">请介绍消息队列推和拉的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E5%92%8CKafka%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">RabbitMQ和Kafka有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9F%E5%BA%A6%E5%BF%AB%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">Kafka为什么速度快？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%B7%B2%E8%BE%BE%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">RabbitMQ如何保证消息已达？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AMQ"><span class="nav-number"></span> <span class="nav-text">补充：MQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">MQ是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0RabbitMQ%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">简述RabbitMQ的架构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-%EF%BC%9F-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">RabbitMQ如何确保消息发送 ？ 消息接收？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="nav-number">4.</span> <span class="nav-text">RabbitMQ事务消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E3%80%81%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">RabbitMQ死信队列、延时队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">RabbitMQ镜像队列机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0kafka%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.</span> <span class="nav-text">简述kafka架构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-%E4%B8%AD%E5%B0%8F%E5%9E%8B%E4%BC%81%E4%B8%9A%E9%A6%96%E9%80%89%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">RabbitMQ(中小型企业首选）</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangxin</p>
  <div class="site-description" itemprop="description">新站点：zxalive.com</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">267</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


    </div>

    <div class="main-inner post posts-expand">

  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zxblog.eu.org/posts/a810/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行博客">
      <meta itemprop="description" content="新站点：zxalive.com">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java工程师面试题-中间件-消息队列 | 知行博客">
      <meta itemprop="description" content="Java工程师面试题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java工程师面试题-中间件-消息队列
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-16 16:47:11" itemprop="dateCreated datePublished" datetime="2022-08-16T16:47:11+08:00">2022-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 18:14:29" itemprop="dateModified" datetime="2024-08-18T18:14:29+08:00">2024-08-18</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

            <div class="post-description">Java工程师面试题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p><code>推荐先阅读</code>：<a href="/posts/b2c4">Java工程师面试题</a></p>
</blockquote>
<h2 id="MQ有什么用？"><a href="#MQ有什么用？" class="headerlink" title="MQ有什么用？"></a>MQ有什么用？</h2><p><strong>参考答案</strong></p>
<p>消息队列有很多使用场景，比较常见的有3个：解耦、异步、削峰。</p>
<ol>
<li>解耦：传统的软件开发模式，各个模块之间相互调用，数据共享，每个模块都要时刻关注其他模块的是否更改或者是否挂掉等等，使用消息队列，可以避免模块之间直接调用，将所需共享的数据放在消息队列中，对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的可扩展性。</li>
<li>异步：消息队列提供了异步处理机制，在很多时候应用不想也不需要立即处理消息，允许应用把一些消息放入消息中间件中，并不立即处理它，在之后需要的时候再慢慢处理。</li>
<li>削峰：在访问量骤增的场景下，需要保证应用系统的平稳性，但是这样突发流量并不常见，如果以这类峰值的标准而投放资源的话，那无疑是巨大的浪费。使用消息队列能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。消息队列的容量可以配置的很大，如果采用磁盘存储消息，则几乎等于“无限”容量，这样一来，高峰期的消息可以被积压起来，在随后的时间内进行平滑的处理完成，而不至于让系统短时间内无法承载而导致崩溃。在电商网站的秒杀抢购这种突发性流量很强的业务场景中，消息队列的强大缓冲能力可以很好的起到削峰作用。</li>
</ol>
<h2 id="说一说生产者与消费者模式"><a href="#说一说生产者与消费者模式" class="headerlink" title="说一说生产者与消费者模式"></a>说一说生产者与消费者模式</h2><p><strong>参考答案</strong></p>
<p>所谓生产者-消费者问题，实际上主要是包含了两类线程。一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库。生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为。而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：</p>
<ol>
<li>如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；</li>
<li>如果共享数据区为空的话，阻塞消费者继续消费数据。</li>
</ol>
<p>在Java语言中，实现生产者消费者问题时，可以采用三种方式：</p>
<ol>
<li>使用 Object 的 wait&#x2F;notify 的消息通知机制；</li>
<li>使用 Lock 的 Condition 的 await&#x2F;signal 的消息通知机制；</li>
<li>使用 BlockingQueue 实现。</li>
</ol>
<h2 id="消息队列如何保证顺序消费？"><a href="#消息队列如何保证顺序消费？" class="headerlink" title="消息队列如何保证顺序消费？"></a>消息队列如何保证顺序消费？</h2><p><strong>参考答案</strong></p>
<p>在生产中经常会有一些类似报表系统这样的系统，需要做 MySQL 的 binlog 同步。比如订单系统要同步订单表的数据到大数据部门的 MySQL 库中用于报表统计分析，通常的做法是基于 Canal 这样的中间件去监听订单数据库的 binlog，然后把这些 binlog 发送到 MQ 中，再由消费者从 MQ 中获取 binlog 落地到大数据部门的 MySQL 中。</p>
<p>在这个过程中，可能会有对某个订单的增删改操作，比如有三条 binlog 执行顺序是增加、修改、删除。消费者愣是换了顺序给执行成删除、修改、增加，这样能行吗？肯定是不行的。不同的消息队列产品，产生消息错乱的原因，以及解决方案是不同的。下面我们以RabbitMQ、Kafka、RocketMQ为例，来说明保证顺序消费的办法。</p>
<p>RabbitMQ：</p>
<p>对于 RabbitMQ 来说，导致上面顺序错乱的原因通常是消费者是集群部署，不同的消费者消费到了同一订单的不同的消息。如消费者A执行了增加，消费者B执行了修改，消费者C执行了删除，但是消费者C执行比消费者B快，消费者B又比消费者A快，就会导致消费 binlog 执行到数据库的时候顺序错乱，本该顺序是增加、修改、删除，变成了删除、修改、增加。</p>
<p>RabbitMQ 的问题是由于不同的消息都发送到了同一个 queue 中，多个消费者都消费同一个 queue 的消息。解决这个问题，我们可以给 RabbitMQ 创建多个 queue，每个消费者固定消费一个 queue 的消息，生产者发送消息的时候，同一个订单号的消息发送到同一个 queue 中，由于同一个 queue 的消息是一定会保证有序的，那么同一个订单号的消息就只会被一个消费者顺序消费，从而保证了消息的顺序性。</p>
<p>Kafka：</p>
<p>对于 Kafka 来说，一个 topic 下同一个 partition 中的消息肯定是有序的，生产者在写的时候可以指定一个 key，通过我们会用订单号作为 key，这个 key 对应的消息都会发送到同一个 partition 中，所以消费者消费到的消息也一定是有序的。</p>
<p>那么为什么 Kafka 还会存在消息错乱的问题呢？问题就出在消费者身上。通常我们消费到同一个 key 的多条消息后，会使用多线程技术去并发处理来提高消息处理速度，否则一条消息的处理需要耗时几十 毫秒，1 秒也就只能处理几十条消息，吞吐量就太低了。而多线程并发处理的话，binlog 执行到数据库的时候就不一定还是原来的顺序了。</p>
<p>Kafka 从生产者到消费者消费消息这一整个过程其实都是可以保证有序的，导致最终乱序是由于消费者端需要使用多线程并发处理消息来提高吞吐量，比如消费者消费到了消息以后，开启 32 个线程处理消息，每个线程线程处理消息的快慢是不一致的，所以才会导致最终消息有可能不一致。</p>
<p>所以对于 Kafka 的消息顺序性保证，其实我们只需要保证同一个订单号的消息只被同一个线程处理的就可以了。由此我们可以在线程处理前增加个内存队列，每个线程只负责处理其中一个内存队列的消息，同一个订单号的消息发送到同一个内存队列中即可。</p>
<p>RocketMQ：</p>
<p>对于 RocketMQ 来说，每个 Topic 可以指定多个 MessageQueue，当我们写入消息的时候，会把消息均匀地分发到不同的 MessageQueue 中，比如同一个订单号的消息，增加 binlog 写入到 MessageQueue1 中，修改 binlog 写入到 MessageQueue2 中，删除 binlog 写入到 MessageQueue3 中。</p>
<p>但是当消费者有多台机器的时候，会组成一个 Consumer Group，Consumer Group 中的每台机器都会负责消费一部分 MessageQueue 的消息，所以可能消费者A消费了 MessageQueue1 的消息执行增加操作，消费者B消费了 MessageQueue2 的消息执行修改操作，消费者C消费了 MessageQueue3 的消息执行删除操作，但是此时消费 binlog 执行到数据库的时候就不一定是消费者A先执行了，有可能消费者C先执行删除操作，因为几台消费者是并行执行，是不能够保证他们之间的执行顺序的。</p>
<p>RocketMQ 的消息乱序是由于同一个订单号的 binlog 进入了不同的 MessageQueue，进而导致一个订单的 binlog 被不同机器上的 Consumer 处理。</p>
<p>要解决 RocketMQ 的乱序问题，我们只需要想办法让同一个订单的 binlog 进入到同一个 MessageQueue 中就可以了。因为同一个 MessageQueue 内的消息是一定有序的，一个 MessageQueue 中的消息只能交给一个 Consumer 来进行处理，所以 Consumer 消费的时候就一定会是有序的。</p>
<h2 id="消息队列如何保证消息不丢？"><a href="#消息队列如何保证消息不丢？" class="headerlink" title="消息队列如何保证消息不丢？"></a>消息队列如何保证消息不丢？</h2><p><strong>参考答案</strong></p>
<p>丢数据一般分为两种，一种是mq把消息丢了，一种就是消费时将消息丢了。下面从rabbitmq和kafka分别说一下，丢失数据的场景。</p>
<p>RabbitMQ：</p>
<p>RabbitMQ丢失消息分为如下几种情况：</p>
<ol>
<li><p>生产者丢消息：</p>
<p>生产者将数据发送到RabbitMQ的时候，可能在传输过程中因为网络等问题而将数据弄丢了。</p>
</li>
<li><p>RabbitMQ自己丢消息：</p>
<p>如果没有开启RabbitMQ的持久化，那么RabbitMQ一旦重启数据就丢了。所以必须开启持久化将消息持久化到磁盘，这样就算RabbitMQ挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢失。除非极其罕见的情况，RabbitMQ还没来得及持久化自己就挂了，这样可能导致一部分数据丢失。</p>
</li>
<li><p>消费端丢消息：</p>
<p>主要是因为消费者消费时，刚消费到还没有处理，结果消费者就挂了，这样你重启之后，RabbitMQ就认为你已经消费过了，然后就丢了数据。</p>
</li>
</ol>
<p>针对上述三种情况，RabbitMQ可以采用如下方式避免消息丢失：</p>
<ol>
<li><p>生产者丢消息：</p>
<ul>
<li>可以选择使用RabbitMQ提供是事务功能，就是生产者在发送数据之前开启事务，然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会受到异常报错，这时就可以回滚事务，然后尝试重新发送。如果收到了消息，那么就可以提交事务。这种方式有明显的缺点，即RabbitMQ事务开启后，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降。</li>
<li>可以开启confirm模式。在生产者那里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如何写入了RabbitMQ之中，RabbitMQ会给你回传一个ack消息，告诉你这个消息发送OK了。如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。</li>
</ul>
<p>事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后RabbitMQ会回调告知成功与否。 一般在生产者这块避免丢失，都是用confirm机制。</p>
</li>
<li><p>RabbitMQ自己丢消息：</p>
<p>设置消息持久化到磁盘，设置持久化有两个步骤：</p>
<ul>
<li>创建queue的时候将其设置为持久化的，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里面的数据。</li>
<li>发送消息的时候讲消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时RabbitMQ就会将消息持久化到磁盘上。 必须要同时开启这两个才可以。</li>
</ul>
<p>而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前RabbitMQ挂了，数据丢了，生产者收不到ack回调也会进行消息重发。</p>
</li>
<li><p>消费端丢消息：</p>
<p>使用RabbitMQ提供的ack机制，首先关闭RabbitMQ的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。</p>
</li>
</ol>
<p>Kafka：</p>
<p>Kafka丢失消息分为如下几种情况：</p>
<ol>
<li><p>生产者丢消息：</p>
<p>生产者没有设置相应的策略，发送过程中丢失数据。</p>
</li>
<li><p>Kafka自己丢消息：</p>
<p>比较常见的一个场景，就是Kafka的某个broker宕机了，然后重新选举partition的leader时。如果此时follower还没来得及同步数据，leader就挂了，然后某个follower成为了leader，它就少了一部分数据。</p>
</li>
<li><p>消费端丢消息：</p>
<p>消费者消费到了这个数据，然后消费之自动提交了offset，让Kafka知道你已经消费了这个消息，当你准备处理这个消息时，自己挂掉了，那么这条消息就丢了。</p>
</li>
</ol>
<p>针对上述三种情况，Kafka可以采用如下方式避免消息丢失：</p>
<ol>
<li><p>生产者丢消息：</p>
<p>关闭自动提交offset，在自己处理完毕之后手动提交offset，这样就不会丢失数据。</p>
</li>
<li><p>Kafka自己丢消息：</p>
<p>一般要求设置4个参数来保证消息不丢失：</p>
<ul>
<li>给topic设置 replication.factor 参数，这个值必须大于1，表示要求每个partition必须至少有2个副本。</li>
<li>在kafka服务端设置 min.isync.replicas 参数，这个值必须大于1，表示 要求一个leader至少感知到有至少一个follower在跟自己保持联系正常同步数据，这样才能保证leader挂了之后还有一个follower。</li>
<li>在生产者端设置 acks&#x3D;all ，表示 要求每条每条数据，必须是写入所有replica副本之后，才能认为是写入成功了。</li>
<li>在生产者端设置 retries&#x3D;MAX (很大的一个值)，表示这个是要求一旦写入事变，就无限重试。</li>
</ul>
</li>
<li><p>消费端丢消息：</p>
<p>如果按照上面设置了ack&#x3D;all，则一定不会丢失数据，要求是，你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>
</li>
</ol>
<h2 id="消息队列如何保证不重复消费？"><a href="#消息队列如何保证不重复消费？" class="headerlink" title="消息队列如何保证不重复消费？"></a>消息队列如何保证不重复消费？</h2><p><strong>参考答案</strong></p>
<p>先大概说一说可能会有哪些重复消费的问题。首先就是比如rabbitmq、rocketmq、kafka，都有可能会出现消费重复消费的问题，正常。因为这问题通常不是mq自己保证的，是给你保证的。然后我们挑一个kafka来举个例子，说说怎么重复消费吧。</p>
<p>kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的offset来继续消费吧。</p>
<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接kill进程了，再重启。这会导致consumer有些消息处理了，但是没来得及提交offset，尴尬了。重启之后，少数消息会再次消费一次。</p>
<p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。举个例子,假设你有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下已经消费过了，直接扔了，不就保留了一条数据？</p>
<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性幂等性。通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</p>
<p>想要保证不重复消费，其实还要结合业务来思考，这里给几个思路：</p>
<ol>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下。</li>
<li>比如你是写redis，那没问题了，反正每次都是set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
</ol>
<p>还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据。</p>
<h2 id="MQ处理消息失败了怎么办？"><a href="#MQ处理消息失败了怎么办？" class="headerlink" title="MQ处理消息失败了怎么办？"></a>MQ处理消息失败了怎么办？</h2><p><strong>参考答案</strong></p>
<p>一般生产环境中，都会在使用MQ的时候设计两个队列：一个是核心业务队列，一个是死信队列。核心业务队列，就是比如专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。</p>
<p>比如说要是第三方物流系统故障了，此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送，都会遇到对方的接口报错。此时仓储系统就可以把这条消息拒绝访问，或者标志位处理失败！注意，这个步骤很重要。</p>
<p>一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中。然后你会看到的就是，在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。然后你的仓储系统得专门有一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新执行发货和配送的通知逻辑。死信队列的使用，其实就是MQ在生产实践中非常重要的一环，也就是架构设计必须要考虑的。</p>
<h2 id="请介绍消息队列推和拉的使用场景"><a href="#请介绍消息队列推和拉的使用场景" class="headerlink" title="请介绍消息队列推和拉的使用场景"></a>请介绍消息队列推和拉的使用场景</h2><p><strong>参考答案</strong></p>
<p>推模式：</p>
<p>推模式是服务器端根据用户需要，由目的、按时将用户感兴趣的信息主动发送到用户的客户端。</p>
<p>优点：</p>
<ul>
<li>对用户要求低，方便用户获取需要的信息；</li>
<li>及时性好，服务器端及时地向客户端推送更新动态信息，吞吐量大。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能确保发送成功，推模式采用广播方式，只有服务器端和客户端在同一个频道上，推模式才有效，用户才能接收到信息；</li>
<li>没有信息状态跟踪，推模式采用开环控制技术，一个信息推送后的状态，比如客户端是否接收等，无从得知；</li>
<li>针对性较差。推送的信息可能并不能满足客户端的个性化需求。</li>
</ul>
<p>拉模式：</p>
<p>拉模式是客户端主动从服务器端获取信息。</p>
<p>优点：</p>
<ul>
<li>针对性强，能满足客户端的个性化需求；</li>
<li>信息传输量较小，网络中传输的只是客户端的请求和服务器端对该请求的响应；</li>
<li>服务器端的任务轻。服务器端只是被动接收查询，对客户端的查询请求做出响应。</li>
</ul>
<p>缺点：</p>
<ul>
<li>实时性较差，针对于服务器端实时更新的信息，客户端难以获取实时信息；</li>
<li>对于客户端用户的要求较高，需要对服务器端具有一定的了解。</li>
</ul>
<h2 id="RabbitMQ和Kafka有什么区别？"><a href="#RabbitMQ和Kafka有什么区别？" class="headerlink" title="RabbitMQ和Kafka有什么区别？"></a>RabbitMQ和Kafka有什么区别？</h2><p><strong>参考答案</strong></p>
<p>在实际生产应用中，通常会使用Kafka作为消息传输的数据管道，RabbitMQ作为交易数据作为数据传输管道，主要的取舍因素则是是否存在丢数据的可能。RabbitMQ在金融场景中经常使用，具有较高的严谨性，数据丢失的可能性更小，同事具备更高的实时性。而Kafka优势主要体现在吞吐量上，虽然可以通过策略实现数据不丢失，但从严谨性角度来讲，大不如RabbitMQ。而且由于Kafka保证每条消息最少送达一次，有较小的概率会出现数据重复发送的情况。详细来说，它们之间主要有如下的区别：</p>
<ol>
<li><p>应用场景方面</p>
<p>RabbitMQ：用于实时的，对可靠性要求较高的消息传递上。</p>
<p>Kafka：用于处于活跃的流式数据，大数据量的数据处理上。</p>
</li>
<li><p>架构模型方面</p>
<p>RabbitMQ：以broker为中心，有消息的确认机制。</p>
<p>Kafka：以consumer为中心，没有消息的确认机制。</p>
</li>
<li><p>吞吐量方面</p>
<p>RabbitMQ：支持消息的可靠的传递，支持事务，不支持批量操作，基于存储的可靠性的要求存储可以采用内存或硬盘，吞吐量小。</p>
<p>Kafka：内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高，吞吐量高。</p>
</li>
<li><p>集群负载均衡方面</p>
<p>RabbitMQ：本身不支持负载均衡，需要loadbalancer的支持。</p>
<p>Kafka：采用zookeeper对集群中的broker，consumer进行管理，可以注册topic到zookeeper上，通过zookeeper的协调机制，producer保存对应的topic的broker信息，可以随机或者轮询发送到broker上，producer可以基于语义指定分片，消息发送到broker的某个分片上。</p>
</li>
</ol>
<h2 id="Kafka为什么速度快？"><a href="#Kafka为什么速度快？" class="headerlink" title="Kafka为什么速度快？"></a>Kafka为什么速度快？</h2><p><strong>参考答案</strong></p>
<p>Kafka的消息是保存或缓存在磁盘上的，一般认为在磁盘上读写数据是会降低性能的，因为寻址会比较消耗时间，但是实际上，Kafka的特性之一就是高吞吐率。即使是普通的服务器，Kafka也可以轻松支持每秒百万级的写入请求，超过了大部分的消息中间件，这种特性也使得Kafka在日志处理等海量数据场景广泛应用。</p>
<p>下面从数据写入和读取两方面分析，为什么Kafka速度这么快：</p>
<p>写入数据：</p>
<p>Kafka会把收到的消息都写入到硬盘中，它绝对不会丢失数据。为了优化写入速度Kafka采用了两个技术，顺序写入和MMFile 。</p>
<p>一、顺序写入</p>
<p>磁盘读写的快慢取决于你怎么使用它，也就是顺序读写或者随机读写。在顺序读写的情况下，磁盘的顺序读写速度和内存持平。因为硬盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最讨厌随机I&#x2F;O，最喜欢顺序I&#x2F;O。为了提高读写硬盘的速度，Kafka就是使用顺序I&#x2F;O。</p>
<p>而且Linux对于磁盘的读写优化也比较多，包括read-ahead和write-behind，磁盘缓存等。如果在内存做这些操作的时候，一个是JAVA对象的内存开销很大，另一个是随着堆内存数据的增多，JAVA的GC时间会变得很长，使用磁盘操作有以下几个好处：</p>
<ol>
<li>磁盘顺序读写速度超过内存随机读写；</li>
<li>JVM的GC效率低，内存占用大。使用磁盘可以避免这一问题；</li>
<li>系统冷启动后，磁盘缓存依然可用。</li>
</ol>
<p>下图就展示了Kafka是如何写入数据的， 每一个Partition其实都是一个文件 ，收到消息后Kafka会把数据插入到文件末尾（虚框部分）：</p>
<p><img src="/../../assets/KMn14QrRDiywx7u.webp"></p>
<p>这种方法有一个缺陷——没有办法删除数据 ，所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示读取到了第几条数据 。</p>
<p><img src="/../../assets/LWa5Ghmdi2kMAPp.webp"></p>
<p>二、Memory Mapped Files</p>
<p>即便是顺序写入硬盘，硬盘的访问速度还是不可能追上内存。所以Kafka的数据并不是实时的写入硬盘 ，它充分利用了现代操作系统分页存储来利用内存提高I&#x2F;O效率。Memory Mapped Files(后面简称mmap)也被翻译成 内存映射文件，在64位操作系统中一般可以表示20G的数据文件，它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。</p>
<p>通过mmap，进程像读写硬盘一样读写内存（当然是虚拟机内存），也不必关心内存的大小有虚拟内存为我们兜底。使用这种方式可以获取很大的I&#x2F;O提升，省去了用户空间到内核空间复制的开销（调用文件的read会把数据先放到内核空间的内存中，然后再复制到用户空间的内存中。）</p>
<p>但也有一个很明显的缺陷——不可靠，写到mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用flush的时候才把数据真正的写到硬盘。Kafka提供了一个参数——producer.type来控制是不是主动flush，如果Kafka写入到mmap之后就立即flush然后再返回Producer叫 同步 (sync)；写入mmap之后立即返回Producer不调用flush叫异步 (async)。</p>
<p>读取数据：</p>
<p>一、基于sendfile实现Zero Copy</p>
<p>传统模式下，当需要对一个文件进行传输的时候，其具体流程细节如下：</p>
<ul>
<li>调用read函数，文件数据被copy到内核缓冲区；</li>
<li>read函数返回，文件数据从内核缓冲区copy到用户缓冲区；</li>
<li>write函数调用，将文件数据从用户缓冲区copy到内核与socket相关的缓冲区；</li>
<li>数据从socket缓冲区copy到相关协议引擎。</li>
</ul>
<p>以上细节是传统read&#x2F;write方式进行网络文件传输的方式，我们可以看到，在这个过程当中，文件数据实际上是经过了四次copy操作：硬盘-&gt;内核buf-&gt;用户buf-&gt;socket相关缓冲区-&gt;协议引擎。而sendfile系统调用则提供了一种减少以上多次copy，提升文件传输性能的方法。</p>
<p>在内核版本2.1中，引入了sendfile系统调用，以简化网络上和两个本地文件之间的数据传输。sendfile的引入不仅减少了数据复制，还减少了上下文切换。运行流程如下：</p>
<ul>
<li>sendfile系统调用，文件数据被copy至内核缓冲区；</li>
<li>再从内核缓冲区copy至内核中socket相关的缓冲区；</li>
<li>最后再socket相关的缓冲区copy到协议引擎。</li>
</ul>
<p>相较传统read&#x2F;write方式，2.1版本内核引进的sendfile已经减少了内核缓冲区到user缓冲区，再由user缓冲区到socket相关缓冲区的文件copy，而在内核版本2.4之后，文件描述符结果被改变，sendfile实现了更简单的方式，再次减少了一次copy操作。</p>
<p>在Apache、Nginx、lighttpd等web服务器当中，都有一项sendfile相关的配置，使用sendfile可以大幅提升文件传输性能。Kafka把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候Kafka直接把文件发送给消费者，配合mmap作为文件读写方式，直接把它传给sendfile。</p>
<p>二、批量压缩</p>
<p>在很多情况下，系统的瓶颈不是CPU或磁盘，而是网络IO，对于需要在广域网上的数据中心之间发送消息的数据流水线尤其如此。进行数据压缩会消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑。</p>
<ul>
<li>如果每个消息都压缩，但是压缩率相对很低，所以Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩；</li>
<li>Kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩；</li>
<li>Kafka支持多种压缩协议，包括Gzip和Snappy压缩协议。</li>
</ul>
<p>总结：</p>
<p>Kafka速度的秘诀在于，它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗，通过mmap提高I&#x2F;O速度，写入数据的时候由于单个Partion是末尾添加所以速度最优。读取数据的时候配合sendfile直接暴力输出。</p>
<h2 id="RabbitMQ如何保证消息已达？"><a href="#RabbitMQ如何保证消息已达？" class="headerlink" title="RabbitMQ如何保证消息已达？"></a>RabbitMQ如何保证消息已达？</h2><p><strong>参考答案</strong></p>
<p>RabbitMQ可能丢失消息分为如下几种情况：</p>
<ol>
<li><p>生产者丢消息：</p>
<p>生产者将数据发送到RabbitMQ的时候，可能在传输过程中因为网络等问题而将数据弄丢了。</p>
</li>
<li><p>RabbitMQ自己丢消息：</p>
<p>如果没有开启RabbitMQ的持久化，那么RabbitMQ一旦重启数据就丢了。所以必须开启持久化将消息持久化到磁盘，这样就算RabbitMQ挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢失。除非极其罕见的情况，RabbitMQ还没来得及持久化自己就挂了，这样可能导致一部分数据丢失。</p>
</li>
<li><p>消费端丢消息：</p>
<p>主要是因为消费者消费时，刚消费到还没有处理，结果消费者就挂了，这样你重启之后，RabbitMQ就认为你已经消费过了，然后就丢了数据。</p>
</li>
</ol>
<p>针对上述三种情况，RabbitMQ可以采用如下方式避免消息丢失：</p>
<ol>
<li><p>生产者丢消息：</p>
<ul>
<li>可以选择使用RabbitMQ提供是事务功能，就是生产者在发送数据之前开启事务，然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会受到异常报错，这时就可以回滚事务，然后尝试重新发送。如果收到了消息，那么就可以提交事务。这种方式有明显的缺点，即RabbitMQ事务开启后，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降。</li>
<li>可以开启confirm模式。在生产者那里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如何写入了RabbitMQ之中，RabbitMQ会给你回传一个ack消息，告诉你这个消息发送OK了。如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。</li>
</ul>
<p>事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后RabbitMQ会回调告知成功与否。 一般在生产者这块避免丢失，都是用confirm机制。</p>
</li>
<li><p>RabbitMQ自己丢消息：</p>
<p>设置消息持久化到磁盘，设置持久化有两个步骤：</p>
<ul>
<li>创建queue的时候将其设置为持久化的，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里面的数据。</li>
<li>发送消息的时候讲消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时RabbitMQ就会将消息持久化到磁盘上。 必须要同时开启这两个才可以。</li>
</ul>
<p>而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前RabbitMQ挂了，数据丢了，生产者收不到ack回调也会进行消息重发。</p>
</li>
<li><p>消费端丢消息：</p>
<p>使用RabbitMQ提供的ack机制，首先关闭RabbitMQ的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。</p>
</li>
</ol>
<h1 id="补充：MQ"><a href="#补充：MQ" class="headerlink" title="补充：MQ"></a>补充：MQ</h1><h2 id="MQ是什么"><a href="#MQ是什么" class="headerlink" title="MQ是什么"></a>MQ是什么</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/%E9%9D%A2%E8%AF%95%E9%A2%98/54152397?sort=created">https://www.zhihu.com/面试题/54152397?sort=created</a></p>
<h2 id="简述RabbitMQ的架构设计"><a href="#简述RabbitMQ的架构设计" class="headerlink" title="简述RabbitMQ的架构设计"></a>简述RabbitMQ的架构设计</h2><p><img src="/../../assets/FRueWC4bojvs3Zi.png"></p>
<p>Broker：rabbitmq的服务节点</p>
<p>Queue：队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的 消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注 意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑 定多个队列，由多个消费者来订阅这些队列的方式。</p>
<p>Exchange：交换器。生产者将消息发送到Exchange，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。</p>
<p>RoutingKey：路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定 这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。 在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消息流向哪里。</p>
<p>Binding：通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ 就可以指定如何正确的路由到队列了。</p>
<p>交换器和队列实际上是多对多关系。就像关系数据库中的两张表。他们通过BindingKey做关联(多对多 关系表)。在投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。</p>
<p>信道：信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候， 客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。</p>
<h2 id="RabbitMQ如何确保消息发送-？-消息接收？"><a href="#RabbitMQ如何确保消息发送-？-消息接收？" class="headerlink" title="RabbitMQ如何确保消息发送 ？ 消息接收？"></a>RabbitMQ如何确保消息发送 ？ 消息接收？</h2><p>发送方确认机制：</p>
<blockquote>
<p>信道需要设置为 confirm 模式，则所有在信道上发布的消息都会分配一个唯一 ID。</p>
<p>一旦消息被投递到queue（可持久化的消息需要写入磁盘），信道会发送一个确认给生产者（包含消息唯一 ID）。</p>
<p>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（未确认）消息给生产者。</p>
<p>所有被发送的消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做 任何保证，并且同一条消息不会既被 confirm又被nack</p>
<p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者， 生产者的回调方法会被触发。</p>
<p>ConfirmCallback接口：只确认是否正确到达 Exchange 中，成功到达则回调</p>
<p>ReturnCallback接口：消息失败返回时回调</p>
</blockquote>
<p>接收方确认机制：</p>
<blockquote>
<p>消费者在声明队列时，可以指定noAck参数，当noAck&#x3D;false时，RabbitMQ会等待消费者显式发回ack信号 后才从内存(或者磁盘，持久化消息)中移去消息。否则，消息被消费后会被立即删除。</p>
<p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息， RabbitMQ 才能安全地把消息从队列中删除。</p>
<p>RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该 消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很长。保 证数据的最终一致性；</p>
<p>如果消费者返回ack之前断开了链接，RabbitMQ 会重新分发给下一个订阅的消费者。（可能存在消息重复消 费的隐患，需要去重）</p>
</blockquote>
<h2 id="RabbitMQ事务消息"><a href="#RabbitMQ事务消息" class="headerlink" title="RabbitMQ事务消息"></a>RabbitMQ事务消息</h2><p>通过对信道的设置实现</p>
<ol>
<li>channel.txSelect()；通知服务器开启事务模式；服务端会返回Tx.Select-Ok</li>
<li>channel.basicPublish；发送消息，可以是多条，可以是消费消息提交ack</li>
<li>channel.txCommit()提交事务；</li>
<li>channel.txRollback()回滚事务；</li>
</ol>
<p>消费者使用事务：</p>
<ol>
<li>autoAck&#x3D;false，手动提交ack，以事务提交或回滚为准；</li>
<li>autoAck&#x3D;true，不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队 列已经把消息移除了</li>
</ol>
<p>如果其中任意一个环节出现问题，就会抛出IoException异常，用户可以拦截异常进行事务回滚，或决 定要不要重复消息。</p>
<p>事务消息会降低rabbitmq的性能</p>
<h2 id="RabbitMQ死信队列、延时队列"><a href="#RabbitMQ死信队列、延时队列" class="headerlink" title="RabbitMQ死信队列、延时队列"></a>RabbitMQ死信队列、延时队列</h2><ol>
<li>消息被消费方否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时 requeue 属性被设置为 false 。</li>
<li>消息在队列的存活时间超过设置的TTL时间。</li>
<li>消息队列的消息数量已经超过最大队列长度。</li>
</ol>
<p>那么该消息将成为“死信”。“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该 消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃</p>
<p>为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然 后为每个业务队列分配一个单独的路由key，死信队列只不过是绑定在死信交换机上的队列，死信交换 机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、 Fanout、Topic】</p>
<p>TTL：一条消息或者该队列中的所有消息的最大存活时间</p>
<p>如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没 有被消费，则会成为“死信”。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。</p>
<p>只需要消费者一直消费死信队列里的消息</p>
<h2 id="RabbitMQ镜像队列机制"><a href="#RabbitMQ镜像队列机制" class="headerlink" title="RabbitMQ镜像队列机制"></a>RabbitMQ镜像队列机制</h2><p>镜像queue有master节点和slave节点。master和slave是针对一个queue而言的，而不是一个node作 为所有queue的master，其它node作为slave。一个queue第一次创建的node为它的master节点，其 它node为slave节点。</p>
<p>无论客户端的请求打到master还是slave最终数据都是从master节点获取。当请求打到master节点时， master节点直接将消息返回给client，同时master节点会通过GM（Guaranteed Multicast）协议将 queue的最新状态广播到slave节点。GM保证了广播消息的原子性，即要么都更新要么都不更新。</p>
<p>当请求打到slave节点时，slave节点需要将请求先重定向到master节点，master节点将将消息返回给 client，同时master节点会通过GM协议将queue的最新状态广播到slave节点。</p>
<p>如果有新节点加入，RabbitMQ不会同步之前的历史数据，新节点只会复制该节点加入到集群之后新增 的消息。</p>
<h2 id="简述kafka架构设计"><a href="#简述kafka架构设计" class="headerlink" title="简述kafka架构设计"></a>简述kafka架构设计</h2><p><img src="/../../assets/jJ9PTo3sfbwY1rD.png"></p>
<p><strong>Consumer</strong> <strong>Group</strong>：消费者组，消费者组内每个消费者负责消费不同分区的数据，提高消费能力。逻 辑上的一个订阅者。</p>
<p><strong>Topic</strong>：可以理解为一个队列，Topic 将消息分类，生产者和消费者面向的是同一个 Topic。</p>
<p><strong>Partition</strong>：为了实现扩展性，提高并发能力，一个Topic 以多个Partition的方式分布到多个 Broker 上，每个 Partition 是一个 有序的队列。一个 Topic 的每个Partition都有若干个副本（Replica），一个 Leader 和若干个 Follower。生产者发送数据的对象，以及消费者消费数据的对象，都是 Leader。 Follower负责实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个 Follower 还会成为新的 Leader。</p>
<p><strong>Offset</strong>：消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从 消费位置继续消费。</p>
<p><strong>Zookeeper</strong>：Kafka 集群能够正常工作，需要依赖于 Zookeeper，Zookeeper 帮助 Kafka 存储和管理 集群信息。</p>
<h2 id="RabbitMQ-中小型企业首选）"><a href="#RabbitMQ-中小型企业首选）" class="headerlink" title="RabbitMQ(中小型企业首选）"></a>RabbitMQ(中小型企业首选）</h2><p><strong>SpringAMQP</strong></p>
<p><img src="/../../assets/7ykoE5NSZ8FVc6b.png"></p>
<p><img src="/../../assets/7r58unDshyOo46L.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepartmentDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Department, String&gt;, JpaSpecificationExecutor&lt;Department&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Java工程师面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/d2cc/" rel="prev" title="Java工程师面试题-中间件-Redis">
                  <i class="fa fa-angle-left"></i> Java工程师面试题-中间件-Redis
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/f2bf/" rel="next" title="Java工程师面试题-中间件-搜索引擎">
                  Java工程师面试题-中间件-搜索引擎 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhangxin</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:53</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
