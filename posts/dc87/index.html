  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zxblog.eu.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java工程师面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="Java工程师面试题-web开发-Spring">
<meta property="og:url" content="https://zxblog.eu.org/posts/dc87/index.html">
<meta property="og:site_name" content="知行博客">
<meta property="og:description" content="Java工程师面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zxblog.eu.org/assets/gN8conpjUJH7mik.png">
<meta property="article:published_time" content="2022-08-16T08:42:23.000Z">
<meta property="article:modified_time" content="2024-08-18T10:14:29.250Z">
<meta property="article:author" content="zhangxin">
<meta property="article:tag" content="Java工程师面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zxblog.eu.org/assets/gN8conpjUJH7mik.png">


<link rel="canonical" href="https://zxblog.eu.org/posts/dc87/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zxblog.eu.org/posts/dc87/","path":"posts/dc87/","title":"Java工程师面试题-web开发-Spring"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java工程师面试题-web开发-Spring | 知行博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">知行博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">新站点：zxalive.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">请你说说Spring的核心是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">说一说你对Spring容器的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9BeanFactory%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">说一说你对BeanFactory的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9Spring-IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">说一说你对Spring IOC的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Bean%E7%9A%84%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">Spring是如何管理Bean的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8DBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">6.</span> <span class="nav-text">介绍Bean的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.</span> <span class="nav-text">说一说Bean的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">Spring是怎么解决循环依赖的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Autowired%E5%92%8C-Resource%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">@Autowired和@Resource注解有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">Spring中默认提供的单例是线程安全的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9Spring-AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">11.</span> <span class="nav-text">说一说你对Spring AOP的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4AOP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">12.</span> <span class="nav-text">请你说说AOP的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP%E4%B8%8D%E8%83%BD%E5%AF%B9%E5%93%AA%E4%BA%9B%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%BC%BA%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">Spring AOP不能对哪些类进行增强？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">JDK动态代理和CGLIB有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A2%E7%84%B6%E6%9C%89%E6%B2%A1%E6%9C%89%E6%8E%A5%E5%8F%A3%E9%83%BD%E5%8F%AF%E4%BB%A5%E7%94%A8CGLIB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88Spring%E8%BF%98%E8%A6%81%E4%BD%BF%E7%94%A8JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">既然有没有接口都可以用CGLIB，为什么Spring还要使用JDK动态代理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">Spring如何管理事务？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">Spring的事务传播方式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">Spring的事务如何配置，常用注解有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">说一说你对声明式事务的理解</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangxin</p>
  <div class="site-description" itemprop="description">新站点：zxalive.com</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">267</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


    </div>

    <div class="main-inner post posts-expand">

  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zxblog.eu.org/posts/dc87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行博客">
      <meta itemprop="description" content="新站点：zxalive.com">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java工程师面试题-web开发-Spring | 知行博客">
      <meta itemprop="description" content="Java工程师面试题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java工程师面试题-web开发-Spring
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-16 16:42:23" itemprop="dateCreated datePublished" datetime="2022-08-16T16:42:23+08:00">2022-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 18:14:29" itemprop="dateModified" datetime="2024-08-18T18:14:29+08:00">2024-08-18</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

            <div class="post-description">Java工程师面试题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p><code>推荐先阅读</code>：<a href="/posts/b2c4">Java工程师面试题</a></p>
</blockquote>
<h2 id="请你说说Spring的核心是什么"><a href="#请你说说Spring的核心是什么" class="headerlink" title="请你说说Spring的核心是什么"></a>请你说说Spring的核心是什么</h2><p><strong>参考答案</strong></p>
<p>Spring框架包含众多模块，如Core、Testing、Data Access、Web Servlet等，其中Core是整个Spring框架的核心模块。Core模块提供了IoC容器、AOP功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心。</p>
<p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>
<p>说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p>
<p>AOP（Aspect Oriented Programing）是面向切面编程思想，这种思想是对OOP的补充，它可以在OOP的基础上进一步提高编程的效率。简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。</p>
<h2 id="说一说你对Spring容器的了解"><a href="#说一说你对Spring容器的了解" class="headerlink" title="说一说你对Spring容器的了解"></a>说一说你对Spring容器的了解</h2><p><strong>参考答案</strong></p>
<p>Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。</p>
<ul>
<li>BeanFactory：是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</li>
<li>ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</li>
</ul>
<h2 id="说一说你对BeanFactory的了解"><a href="#说一说你对BeanFactory的了解" class="headerlink" title="说一说你对BeanFactory的了解"></a>说一说你对BeanFactory的了解</h2><p><strong>参考答案</strong></p>
<p>BeanFactory是一个类工厂，与传统类工厂不同的是，BeanFactory是类的通用工厂，它可以创建并管理各种类的对象。这些可被创建和管理的对象本身没有什么特别之处，仅是一个POJO，Spring称这些被创建和管理的Java对象为Bean。并且，Spring中所说的Bean比JavaBean更为宽泛一些，所有可以被Spring容器实例化并管理的Java类都可以成为Bean。</p>
<p>BeanFactory是Spring容器的顶层接口，Spring为BeanFactory提供了多种实现，最常用的是XmlBeanFactory。但它在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory替代。BeanFactory最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的Bean。</p>
<h2 id="说一说你对Spring-IOC的理解"><a href="#说一说你对Spring-IOC的理解" class="headerlink" title="说一说你对Spring IOC的理解"></a>说一说你对Spring IOC的理解</h2><p><strong>参考答案</strong></p>
<p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>
<p>说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p>
<p>在具体的实现中，主要由三种注入方式：</p>
<ol>
<li><p>构造方法注入</p>
<p>就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</p>
</li>
<li><p>setter方法注入</p>
<p>通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在对象构造完成后再注入。</p>
</li>
<li><p>接口注入</p>
<p>相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。相对于前两种依赖注入方式，接口注入比较死板和烦琐。</p>
</li>
</ol>
<p>总体来说，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式。而接口注入因为侵入性较强，近年来已经不流行了。</p>
<h2 id="Spring是如何管理Bean的？"><a href="#Spring是如何管理Bean的？" class="headerlink" title="Spring是如何管理Bean的？"></a>Spring是如何管理Bean的？</h2><p><strong>参考答案</strong></p>
<p>Spring通过IoC容器来管理Bean，我们可以通过XML配置或者注解配置，来指导IoC容器对Bean的管理。因为注解配置比XML配置方便很多，所以现在大多时候会使用注解配置的方式。</p>
<p>以下是管理Bean时常用的一些注解：</p>
<ol>
<li>@ComponentScan用于声明扫描策略，通过它的声明，容器就知道要扫描哪些包下带有声明的类，也可以知道哪些特定的类是被排除在外的。</li>
<li>@Component、@Repository、@Service、@Controller用于声明Bean，它们的作用一样，但是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类就可以被容器扫描并创建。</li>
<li>@Autowired、@Qualifier用于注入Bean，即告诉容器应该为当前属性注入哪个Bean。其中，@Autowired是按照Bean的类型进行匹配的，如果这个属性的类型具有多个Bean，就可以通过@Qualifier指定Bean的名称，以消除歧义。</li>
<li>@Scope用于声明Bean的作用域，默认情况下Bean是单例的，即在整个容器中这个类型只有一个实例。可以通过@Scope注解指定prototype值将其声明为多例的，也可以将Bean声明为session级作用域、request级作用域等等，但最常用的还是默认的单例模式。</li>
<li>@PostConstruct、@PreDestroy用于声明Bean的生命周期。其中，被@PostConstruct修饰的方法将在Bean实例化后被调用，@PreDestroy修饰的方法将在容器销毁前被调用。</li>
</ol>
<h2 id="介绍Bean的作用域"><a href="#介绍Bean的作用域" class="headerlink" title="介绍Bean的作用域"></a>介绍Bean的作用域</h2><p><strong>参考答案</strong></p>
<p>默认情况下，Bean在Spring容器中是单例的，我们可以通过@Scope注解修改Bean的作用域。该注解有如下5个取值，它们代表了Bean的5种不同类型的作用域：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">在Spring容器中仅存在一个实例，即Bean以单例的形式存在。</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">每次调用getBean()时，都会执行new操作，返回一个新的实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">每次HTTP请求都会创建一个新的Bean。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。</td>
</tr>
<tr>
<td align="left">globalSession</td>
<td align="left">同一个全局的Session共享一个Bean，一般用于Portlet环境。</td>
</tr>
</tbody></table>
<h2 id="说一说Bean的生命周期"><a href="#说一说Bean的生命周期" class="headerlink" title="说一说Bean的生命周期"></a>说一说Bean的生命周期</h2><p><strong>参考答案</strong></p>
<p>Spring容器管理Bean，涉及对Bean的创建、初始化、调用、销毁等一系列的流程，这个流程就是Bean的生命周期。整个流程参考下图：</p>
<p><img src="/../../assets/gN8conpjUJH7mik.png"></p>
<p>这个过程是由Spring容器自动管理的，其中有两个环节我们可以进行干预。</p>
<ol>
<li>我们可以自定义初始化方法，并在该方法前增加@PostConstruct注解，届时Spring容器将在调用SetBeanFactory方法之后调用该方法。</li>
<li>我们可以自定义销毁方法，并在该方法前增加@PreDestroy注解，届时Spring容器将在自身销毁前，调用这个方法。</li>
</ol>
<h2 id="Spring是怎么解决循环依赖的？"><a href="#Spring是怎么解决循环依赖的？" class="headerlink" title="Spring是怎么解决循环依赖的？"></a>Spring是怎么解决循环依赖的？</h2><p><strong>参考答案</strong></p>
<p>首先，需要明确的是spring对循环依赖的处理有三种情况：</p>
<ol>
<li>构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。</li>
<li>单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。</li>
<li>非单例循环依赖：无法处理。</li>
</ol>
<p>接下来，我们具体看看spring是如何处理第二种循环依赖的。</p>
<p>Spring单例对象的初始化大略分为三步：</p>
<ol>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象；</li>
<li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充；</li>
<li>initializeBean：调用spring xml中的init 方法。</li>
</ol>
<p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一步、第二步。也就是构造器循环依赖和field循环依赖。 Spring为了解决单例的循环依赖问题，使用了三级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name –&gt; bean instance */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>); </span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name –&gt; ObjectFactory */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&gt;(<span class="number">16</span>); </span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name –&gt; bean instance */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">earlySingletonObjects</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存的作用分别是：</p>
<ul>
<li>singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）；</li>
<li>earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）；</li>
<li>singletonObjects：完成初始化的单例对象的cache（一级缓存）。</li>
</ul>
<p>我们在创建bean的时候，会首先从cache中获取这个bean，这个缓存就是sigletonObjects。主要的调用方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;     </span><br><span class="line">  <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);     </span><br><span class="line">  <span class="comment">//isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中     </span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;    </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;          </span><br><span class="line">      singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);      </span><br><span class="line">      <span class="comment">//allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象       </span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;             </span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);     </span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;                   </span><br><span class="line">          singletonObject = singletonFactory.getObject();            </span><br><span class="line">          <span class="comment">//从singletonFactories中移除，并放入earlySingletonObjects中。      </span></span><br><span class="line">          <span class="comment">//其实也就是从三级缓存移动到了二级缓存                     </span></span><br><span class="line">          <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);  </span><br><span class="line">          <span class="built_in">this</span>.singletonFactories.remove(beanName);              </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;  </span><br><span class="line">  T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口在AbstractBeanFactory里实现，并在核心方法doCreateBean（）引用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;     </span><br><span class="line">  Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);    </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;      </span><br><span class="line">      <span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);    </span><br><span class="line">      <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);     </span><br><span class="line">      <span class="built_in">this</span>.registeredSingletons.add(beanName);     </span><br><span class="line">    &#125;     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码发生在createBeanInstance之后，populateBean（）之前，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，此时将这个对象提前曝光出来，让大家使用。</p>
<p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p>
<h2 id="Autowired和-Resource注解有什么区别？"><a href="#Autowired和-Resource注解有什么区别？" class="headerlink" title="@Autowired和@Resource注解有什么区别？"></a>@Autowired和@Resource注解有什么区别？</h2><p><strong>参考答案</strong></p>
<ol>
<li>@Autowired是Spring提供的注解，@Resource是JDK提供的注解。</li>
<li>@Autowired是只能按类型注入，@Resource默认按名称注入，也支持按类型注入。</li>
<li>@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</li>
</ol>
<h2 id="Spring中默认提供的单例是线程安全的吗？"><a href="#Spring中默认提供的单例是线程安全的吗？" class="headerlink" title="Spring中默认提供的单例是线程安全的吗？"></a>Spring中默认提供的单例是线程安全的吗？</h2><p><strong>参考答案</strong></p>
<p>不是。</p>
<p>Spring容器本身并没有提供Bean的线程安全策略。如果单例的Bean是一个无状态的Bean，即线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例的Bean是线程安全的。比如，Controller、Service、DAO这样的组件，通常都是单例且线程安全的。如果单例的Bean是一个有状态的Bean，则可以采用ThreadLocal对状态数据做线程隔离，来保证线程安全。</p>
<h2 id="说一说你对Spring-AOP的理解"><a href="#说一说你对Spring-AOP的理解" class="headerlink" title="说一说你对Spring AOP的理解"></a>说一说你对Spring AOP的理解</h2><p><strong>参考答案</strong></p>
<p>AOP（Aspect Oriented Programming）是面向切面编程，它是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。</p>
<p>AOP的术语：</p>
<ul>
<li>连接点（join point）：对应的是具体被拦截的对象，因为Spring只能支持方法，所以被拦截的对象往往就是指特定的方法，AOP将通过动态代理技术把它织入对应的流程中。</li>
<li>切点（point cut）：有时候，我们的切面不单单应用于单个方法，也可能是多个类的不同方法，这时，可以通过正则式和指示器的规则去定义，从而适配连接点。切点就是提供这样一个功能的概念。</li>
<li>通知（advice）：就是按照约定的流程下的方法，分为前置通知、后置通知、环绕通知、事后返回通知和异常通知，它会根据约定织入流程中。</li>
<li>目标对象（target）：即被代理对象。</li>
<li>引入（introduction）：是指引入新的类和其方法，增强现有Bean的功能。</li>
<li>织入（weaving）：它是一个通过动态代理技术，为原有服务对象生成代理对象，然后将与切点定义匹配的连接点拦截，并按约定将各类通知织入约定流程的过程。</li>
<li>切面（aspect）：是一个可以定义切点、各类通知和引入的内容，SpringAOP将通过它的信息来增强Bean的功能或者将对应的方法织入流程。</li>
</ul>
<p>Spring AOP：</p>
<p>AOP可以有多种实现方式，而Spring AOP支持如下两种实现方式。</p>
<ul>
<li>JDK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。</li>
<li>CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</li>
</ul>
<h2 id="请你说说AOP的应用场景"><a href="#请你说说AOP的应用场景" class="headerlink" title="请你说说AOP的应用场景"></a>请你说说AOP的应用场景</h2><p><strong>参考答案</strong></p>
<p>Spring AOP为IoC的使用提供了更多的便利，一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的日志功能。另一方面，在Spring内部，一些支持模块也是通过Spring AOP来实现的，比如事务处理。从这两个角度就已经可以看到Spring AOP的核心地位了。</p>
<h2 id="Spring-AOP不能对哪些类进行增强？"><a href="#Spring-AOP不能对哪些类进行增强？" class="headerlink" title="Spring AOP不能对哪些类进行增强？"></a>Spring AOP不能对哪些类进行增强？</h2><p><strong>参考答案</strong></p>
<ol>
<li>Spring AOP只能对IoC容器中的Bean进行增强，对于不受容器管理的对象不能增强。</li>
<li>由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。</li>
</ol>
<h2 id="JDK动态代理和CGLIB有什么区别？"><a href="#JDK动态代理和CGLIB有什么区别？" class="headerlink" title="JDK动态代理和CGLIB有什么区别？"></a>JDK动态代理和CGLIB有什么区别？</h2><p><strong>参考答案</strong></p>
<p>JDK动态代理</p>
<p>这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。</p>
<p>CGLib动态代理</p>
<p>采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</p>
<h2 id="既然有没有接口都可以用CGLIB，为什么Spring还要使用JDK动态代理？"><a href="#既然有没有接口都可以用CGLIB，为什么Spring还要使用JDK动态代理？" class="headerlink" title="既然有没有接口都可以用CGLIB，为什么Spring还要使用JDK动态代理？"></a>既然有没有接口都可以用CGLIB，为什么Spring还要使用JDK动态代理？</h2><p><strong>参考答案</strong></p>
<p>在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。所以，对于单例的对象因为无需频繁创建代理对象，采用CGLib动态代理比较合适。反之，对于多例的对象因为需要频繁的创建代理对象，则JDK动态代理更合适。</p>
<h2 id="Spring如何管理事务？"><a href="#Spring如何管理事务？" class="headerlink" title="Spring如何管理事务？"></a>Spring如何管理事务？</h2><p><strong>参考答案</strong></p>
<p>Spring为事务管理提供了一致的编程模板，在高层次上建立了统一的事务抽象。也就是说，不管是选择MyBatis、Hibernate、JPA还是Spring JDBC，Spring都可以让用户以统一的编程模型进行事务管理。</p>
<p>Spring支持两种事务编程模型：</p>
<ol>
<li><p>编程式事务</p>
<p>Spring提供了TransactionTemplate模板，利用该模板我们可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。相对于声明式事务来说，这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确。</p>
</li>
<li><p>声明式事务</p>
<p>Spring事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加@Transactional注解，以声明事务特征即可。</p>
</li>
</ol>
<h2 id="Spring的事务传播方式有哪些？"><a href="#Spring的事务传播方式有哪些？" class="headerlink" title="Spring的事务传播方式有哪些？"></a>Spring的事务传播方式有哪些？</h2><p><strong>参考答案</strong></p>
<p>当我们调用一个业务方法时，它的内部可能会调用其他的业务方法，以完成一个完整的业务操作。这种业务方法嵌套调用的时候，如果这两个方法都是要保证事务的，那么就要通过Spring的事务传播机制控制当前事务如何传播到被嵌套调用的业务方法中。</p>
<p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时如何进行传播，如下表：</p>
<table>
<thead>
<tr>
<th align="left">事务传播类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PROPAGATION_REQUIRED</td>
<td align="left">如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td align="left">PROPAGATION_SUPPORTS</td>
<td align="left">支持当前事务，如果当前没有事务，则以非事务方式执行。</td>
</tr>
<tr>
<td align="left">PROPAGATION_MANDATORY</td>
<td align="left">使用当前的事务，如果当前没有事务，则抛出异常。</td>
</tr>
<tr>
<td align="left">PROPAGATION_REQUIRES_NEW</td>
<td align="left">新建事务，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NOT_SUPPORTED</td>
<td align="left">以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NEVER</td>
<td align="left">以非事务方式执行操作，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NESTED</td>
<td align="left">如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<h2 id="Spring的事务如何配置，常用注解有哪些？"><a href="#Spring的事务如何配置，常用注解有哪些？" class="headerlink" title="Spring的事务如何配置，常用注解有哪些？"></a>Spring的事务如何配置，常用注解有哪些？</h2><p><strong>参考答案</strong></p>
<p>事务的打开、回滚和提交是由事务管理器来完成的，我们使用不同的数据库访问框架，就要使用与之对应的事务管理器。在Spring Boot中，当你添加了数据库访问框架的起步依赖时，它就会进行自动配置，即自动实例化正确的事务管理器。</p>
<p>对于声明式事务，是使用@Transactional进行标注的。这个注解可以标注在类或者方法上。</p>
<ul>
<li>当它标注在类上时，代表这个类所有公共（public）非静态的方法都将启用事务功能。</li>
<li>当它标注在方法上时，代表这个方法将启用事务功能。</li>
</ul>
<p>另外，在@Transactional注解上，我们可以使用isolation属性声明事务的隔离级别，使用propagation属性声明事务的传播机制。</p>
<h2 id="说一说你对声明式事务的理解"><a href="#说一说你对声明式事务的理解" class="headerlink" title="说一说你对声明式事务的理解"></a>说一说你对声明式事务的理解</h2><p><strong>参考答案</strong></p>
<p>Spring事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加@Transactional注解，以声明事务特征即可。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Java工程师面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/fce0/" rel="prev" title="Java工程师面试题-web开发-SpringBoot">
                  <i class="fa fa-angle-left"></i> Java工程师面试题-web开发-SpringBoot
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/af06/" rel="next" title="Java工程师面试题-web开发-SpringMVC">
                  Java工程师面试题-web开发-SpringMVC <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhangxin</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:53</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
