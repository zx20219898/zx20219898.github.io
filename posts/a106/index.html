  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zxblog.eu.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java工程师面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="Java工程师面试题-web开发-ZooKeeper">
<meta property="og:url" content="https://zxblog.eu.org/posts/a106/index.html">
<meta property="og:site_name" content="知行博客">
<meta property="og:description" content="Java工程师面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zxblog.eu.org/assets/tBHRLMI5DFlnb7h.webp">
<meta property="og:image" content="https://zxblog.eu.org/assets/O8FWEKLPCZdGp6N.webp">
<meta property="og:image" content="https://zxblog.eu.org/assets/PMLdtghm9CrSsfa.webp">
<meta property="article:published_time" content="2022-08-16T08:44:22.000Z">
<meta property="article:modified_time" content="2024-08-18T10:14:29.250Z">
<meta property="article:author" content="zhangxin">
<meta property="article:tag" content="Java工程师面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zxblog.eu.org/assets/tBHRLMI5DFlnb7h.webp">


<link rel="canonical" href="https://zxblog.eu.org/posts/a106/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zxblog.eu.org/posts/a106/","path":"posts/a106/","title":"Java工程师面试题-web开发-ZooKeeper"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java工程师面试题-web开发-ZooKeeper | 知行博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">知行博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">新站点：zxalive.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81ZooKeeper-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">1、ZooKeeper 是什么?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Zookeeper-Watcher-%E6%9C%BA%E5%88%B6-%E2%80%93-%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4%E9%80%9A%E7%9F%A5"><span class="nav-number">2.</span> <span class="nav-text">5、Zookeeper Watcher 机制 – 数据变更通知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E5%86%8CWatcher%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">6、客户端注册Watcher实现**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86Watcher%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">7、服务端处理Watcher实现**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9B%9E%E8%B0%83Watcher"><span class="nav-number">5.</span> <span class="nav-text">8、客户端回调Watcher**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%92%E8%89%B2"><span class="nav-number">6.</span> <span class="nav-text">9、服务器角色**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">Zookeeper 通知机制**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">8.</span> <span class="nav-text">Zookeeper 做了什么?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4%E5%92%8C%E4%B8%BB%E5%A4%87%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">主从集群和主备集群的区别？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E4%BF%9D%E8%AF%81%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">zookeeper为什么能保证全局数据一致性？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.</span> <span class="nav-text">Zookeeper有哪几种节点类型**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">Zookeeper 分布式锁(文件系统、通知机制)**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BF%AE%E6%94%B9%E4%BA%86%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%85%B6%E4%BB%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%83%BD%E5%A4%9F%E9%A9%AC%E4%B8%8A%E8%8E%B7%E5%8F%96%E5%88%B0%E8%BF%99%E4%B8%AA%E6%9C%80%E6%96%B0%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="nav-number">14.</span> <span class="nav-text">Zookeeper 数据复制**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zooke-eper-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">15.</span> <span class="nav-text">Zooke**eper 工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper-%E7%9A%84%E7%9B%91%E5%90%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">ZooKeeper 的监听原理是什么？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7-%E7%9A%84"><span class="nav-number">17.</span> <span class="nav-text">zookeeper 是如何保证事务的顺序一致性 的?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89Master%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">分布式集群中为什么会有Master？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper-%E4%B8%8B-Server-%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81"><span class="nav-number">19.</span> <span class="nav-text">Zookeeper 下 Server 工作状态**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper-%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E5%8F%96%E4%B8%BB-leader-%E7%9A%84"><span class="nav-number">20.</span> <span class="nav-text">zookeeper 是如何选取主 leader 的?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper-%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">21.</span> <span class="nav-text">Zookeeper 同步流程**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E7%9F%A5%E5%92%8C%E5%8D%8F%E8%B0%83"><span class="nav-number">22.</span> <span class="nav-text">分布式通知和协调**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-leader"><span class="nav-number">23.</span> <span class="nav-text">机器中为什么会有 leader?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zk-%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">24.</span> <span class="nav-text">zk 节点宕机如何处理?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C-nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-%E5%8C%BA%E5%88%AB"><span class="nav-number">25.</span> <span class="nav-text">zookeeper 负载均衡和 nginx 负载均衡 区别**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%87%A0%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">Zookeeper有哪几种几种部署模式？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%91%E8%A6%81%E5%87%A0%E5%8F%B0%E6%9C%BA%E5%99%A8%EF%BC%8C%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">27.</span> <span class="nav-text">集群最少要几台机器，集群规则是怎样的?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E5%90%97%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">集群支持动态添加机器吗？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper%E5%AF%B9%E8%8A%82%E7%82%B9%E7%9A%84watch%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%98%AF%E6%B0%B8%E4%B9%85%E7%9A%84%E5%90%97%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E6%B0%B8%E4%B9%85%E7%9A%84"><span class="nav-number">29.</span> <span class="nav-text">Zookeeper对节点的watch监听通知是永久的吗？**为什么不是永久的?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZAB%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">ZAB协议是什么？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">31.</span> <span class="nav-text">Zookeeper的典型应用场景**</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B8%83-x2F-%E8%AE%A2%E9%98%85"><span class="nav-number">31.1.</span> <span class="nav-text">1. 数据发布&#x2F;订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">31.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">31.3.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">31.4.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%EF%BC%88%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%EF%BC%89%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">31.5.</span> <span class="nav-text">数据（配置信息）特性：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EZookeeper%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">31.6.</span> <span class="nav-text">基于Zookeeper的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">31.7.</span> <span class="nav-text">2. 负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">31.8.</span> <span class="nav-text">第一种分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">31.9.</span> <span class="nav-text">具体流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">31.10.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="nav-number">31.11.</span> <span class="nav-text">总结一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">31.12.</span> <span class="nav-text">第二种分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">31.13.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B-1"><span class="nav-number">31.14.</span> <span class="nav-text">总结一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">31.15.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangxin</p>
  <div class="site-description" itemprop="description">新站点：zxalive.com</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">267</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


    </div>

    <div class="main-inner post posts-expand">

  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zxblog.eu.org/posts/a106/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行博客">
      <meta itemprop="description" content="新站点：zxalive.com">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java工程师面试题-web开发-ZooKeeper | 知行博客">
      <meta itemprop="description" content="Java工程师面试题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java工程师面试题-web开发-ZooKeeper
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-16 16:44:22" itemprop="dateCreated datePublished" datetime="2022-08-16T16:44:22+08:00">2022-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 18:14:29" itemprop="dateModified" datetime="2024-08-18T18:14:29+08:00">2024-08-18</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

            <div class="post-description">Java工程师面试题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p><code>推荐先阅读</code>：<a href="/posts/b2c4">Java工程师面试题</a></p>
</blockquote>
<h2 id="1、ZooKeeper-是什么"><a href="#1、ZooKeeper-是什么" class="headerlink" title="1、ZooKeeper 是什么?**"></a>1、ZooKeeper 是什么?**</h2><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现， 它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易 用的接口和性能高效、功能稳定的系统提供给用户。客户端的读请求可以被集群中的任意一台机器处理，如果Sidecar 异构开发语言读请求在节点上注册了监听器，这个监听器也是由所 连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请 求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳， 这个时间戳称为 zxid(Zookeeper Transaction Id)。而读请求只会相对于更新有序，也就是读请求的返回 结果中会带有这个 zookeeper 最新的 zxid。</p>
<p><strong>2、ZooKeeper 提供了什么?</strong></p>
<ol>
<li>文件系统</li>
<li>通知机制</li>
</ol>
<p><strong>3、Zookeeper 文件系统</strong></p>
<p>Zookeeper 提供一个多层级的节点命名空间(节点称为 znode)。与文件系统不同的是，这些节点都可以设置 关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延 迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存 放数据上限为 1M。</p>
<p>4、四种类型的数据节点 Znode</p>
<ul>
<li>PERSISTENT-持久节点<br>除非手动删除，否则节点一直存在于Zookeeper上</li>
<li>EPHEMERAL-临时节点<br>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</li>
<li>PERSISTENT_SEQUENTIAL-持久顺序节点<br>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li>
<li>EPHEMERAL_SEQUENTIAL-临时顺序节点<br>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li>
</ul>
<h2 id="5、Zookeeper-Watcher-机制-–-数据变更通知"><a href="#5、Zookeeper-Watcher-机制-–-数据变更通知" class="headerlink" title="5、Zookeeper Watcher 机制 – 数据变更通知"></a>5、Zookeeper Watcher 机制 – 数据变更通知</h2><p>Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。</p>
<p>工作机制：</p>
<ul>
<li>客户端注册watcher</li>
<li>服务端处理watcher</li>
<li>客户端回调watcher</li>
</ul>
<p>Watcher特性总结：</p>
<ol>
<li><p>一次性<br>无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p>
</li>
<li><p>客户端串行执行<br>客户端Watcher回调的过程是一个串行同步的过程。</p>
</li>
<li><p>轻量</p>
</li>
<li><ul>
<li>Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</li>
</ul>
</li>
</ol>
<ul>
<li>客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。</li>
</ul>
<ol start="5">
<li><p>watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。</p>
</li>
<li><p>注册watcher getData、exists、getChildren</p>
</li>
<li><p>触发watcher create、delete、setData</p>
</li>
<li><p>当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。</p>
</li>
</ol>
<h2 id="6、客户端注册Watcher实现"><a href="#6、客户端注册Watcher实现" class="headerlink" title="6、客户端注册Watcher实现**"></a>6、客户端注册Watcher实现**</h2><ol>
<li>调用getData()&#x2F;getChildren()&#x2F;exist()三个API，传入Watcher对象</li>
<li>标记请求request，封装Watcher到WatchRegistration</li>
<li>封装成Packet对象，发服务端发送request</li>
<li>收到服务端响应后，将Watcher注册到ZKWatcherManager中进行管理</li>
<li>请求返回，完成注册。</li>
</ol>
<h2 id="7、服务端处理Watcher实现"><a href="#7、服务端处理Watcher实现" class="headerlink" title="7、服务端处理Watcher实现**"></a>7、服务端处理Watcher实现**</h2><ol>
<li><p>服务端接收Watcher并存储<br>接收到客户端请求，处理请求判断是否需要注册Watcher，需要的话将数据节点的节点路径和ServerCnxn（ServerCnxn代表一个客户端和服务端的连接，实现了Watcher的process接口，此时可以看成一个Watcher对象）存储在WatcherManager的WatchTable和watch2Paths中去。</p>
</li>
<li><p>Watcher触发<br>以服务端接收到 setData() 事务请求触发NodeDataChanged事件为例：</p>
</li>
<li><ul>
<li>封装WatchedEvent<br>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个WatchedEvent对象</li>
</ul>
</li>
</ol>
<ul>
<li>查询Watcher<br>从WatchTable中根据节点路径查找Watcher</li>
<li>没找到；说明没有客户端在该数据节点上注册过Watcher</li>
<li>找到；提取并从WatchTable和Watch2Paths中删除对应Watcher（<strong>从这里可以看出Watcher在服务端是一次性的，触发一次就失效了</strong>）</li>
</ul>
<ol start="4">
<li>调用process方法来触发Watcher<br>这里process主要就是通过ServerCnxn对应的TCP连接发送Watcher事件通知。</li>
</ol>
<h2 id="8、客户端回调Watcher"><a href="#8、客户端回调Watcher" class="headerlink" title="8、客户端回调Watcher**"></a>8、客户端回调Watcher**</h2><p>客户端SendThread线程接收事件通知，交由EventThread线程回调Watcher。客户端的Watcher机制同样是一次性的，一旦被触发后，该Watcher就失效了。</p>
<h2 id="9、服务器角色"><a href="#9、服务器角色" class="headerlink" title="9、服务器角色**"></a>9、服务器角色**</h2><p><strong>Leader</strong></p>
<ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务的调度者</li>
</ul>
<p><strong>Follower</strong></p>
<ul>
<li>处理客户端的非事务请求，转发事务请求给Leader服务器</li>
<li>参与事务请求Proposal的投票</li>
<li>参与Leader选举投票</li>
</ul>
<p><strong>Observer</strong></p>
<p>3.3.0版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</p>
<ul>
<li><p>处理客户端的非事务请求，转发事务请求给Leader服务器</p>
</li>
<li><p>不参与任何形式的投票</p>
</li>
</ul>
<h2 id="Zookeeper-通知机制"><a href="#Zookeeper-通知机制" class="headerlink" title="Zookeeper 通知机制**"></a>Zookeeper 通知机制**</h2><p>client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知， 然后 client 可以根据 znode 变化来做出业务上的改变等。</p>
<h2 id="Zookeeper-做了什么"><a href="#Zookeeper-做了什么" class="headerlink" title="Zookeeper 做了什么?**"></a>Zookeeper 做了什么?**</h2><p>1、命名服务</p>
<p>2、配置管理</p>
<p>3、集群管理</p>
<p>4、分布式锁</p>
<p>5、队列管理</p>
<h2 id="主从集群和主备集群的区别？"><a href="#主从集群和主备集群的区别？" class="headerlink" title="主从集群和主备集群的区别？**"></a>主从集群和主备集群的区别？**</h2><ul>
<li>主从集群：一主多从，主从各司其职，主节点负责资源分配和任务调度，从节点负责具体的执行；</li>
<li>主备集群：一主一备，主要是为了解决单点故障问题，便于备份恢复</li>
</ul>
<h2 id="zookeeper为什么能保证全局数据一致性？"><a href="#zookeeper为什么能保证全局数据一致性？" class="headerlink" title="zookeeper为什么能保证全局数据一致性？**"></a>zookeeper为什么能保证全局数据一致性？**</h2><p>（1）首先，zookeeper集群每个节点都可以接收到客户端请求；</p>
<p>（2）其次，客户端请求分为两种请求，一种请求是事务性请求，另一种是非事务性请求，下边就这两种请求展开论述：</p>
<pre><code>       1）事务性请求：当事务性请求是从节点接收到的，就会将请求转发给主节点，然后让主节点按照时间顺序来指定各个节点完             成请求；当事务性请求是主节点接收到的，主节点将会直接自己按照客户端请求顺序来处理请求；

       2）非事务性请求：任何节点收到了都可以自行处理；
</code></pre>
<h2 id="Zookeeper有哪几种节点类型"><a href="#Zookeeper有哪几种节点类型" class="headerlink" title="Zookeeper有哪几种节点类型**"></a>Zookeeper有哪几种节点类型**</h2><ul>
<li>持久：创建之后一直存在，除非有删除操作，创建节点的客户端会话失效也不影响此节点。</li>
<li>持久顺序：跟持久一样，就是父节点在创建下一级子节点的时候，记录每个子节点创建的先后顺序，会给每个子节点名加上一个数字后缀。</li>
<li>临时：创建客户端会话失效（注意是会话失效，不是连接断了），节点也就没了。不能建子节点。</li>
<li>临时顺序：不用解释了吧。</li>
</ul>
<h2 id="Zookeeper-分布式锁-文件系统、通知机制"><a href="#Zookeeper-分布式锁-文件系统、通知机制" class="headerlink" title="Zookeeper 分布式锁(文件系统、通知机制)**"></a>Zookeeper 分布式锁(文件系统、通知机制)**</h2><p>有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类：</p>
<ol>
<li><strong>保持独占</strong></li>
<li><strong>控制时序</strong></li>
</ol>
<p>对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode 的方式来实现。所有客户 端都去创建 &#x2F;distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。</p>
<p>对于第二类， &#x2F;distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master 一样，编号最小的获得锁，用完删除，依次方便。</p>
<h2 id="一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？"><a href="#一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？" class="headerlink" title="一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？**"></a>一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗？**</h2><p>ZooKeeper 不能确保任何客户端能够获取（即 Read Request）到一样的数据，除非客户端自己要求，方法是客户端在获取数据之前调用 sync。通常情况下（这里所说的通常情况满足：1. 对获取的数据是否是最新版本不敏感，2. 一个客户端修改了数据，其它客户端是否需要立即能够获取最新数据），可以不关心这点。在其它情况下，最清晰的场景是这样：ZK 客户端 A 对 &#x2F;my_test 的内容从 v1-&gt;v2, 但是 ZK 客户端 B 对 &#x2F;my_test 的内容获取，依然得到的是 v1. 请注意，这个是实际存在的现象，当然延时很短。解决的方法是客户端 B 先调用 sync(), 再调用 getData()。</p>
<h2 id="Zookeeper-数据复制"><a href="#Zookeeper-数据复制" class="headerlink" title="Zookeeper 数据复制**"></a>Zookeeper 数据复制**</h2><p>Zookeeper 作为一个集群提供一致的数据服务，自然，它要在<strong>所有机器间做数据复制</strong>。数据复制的好处：</p>
<ol>
<li><strong>容错：</strong>一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作。</li>
<li><strong>提高系统的扩展能力：</strong>把负载分布到多个节点上，或者增加节点来提高系统的负载能力。</li>
<li><strong>提高性能：</strong>让客户端本地访问就近的节点，提高用户访问速度。</li>
</ol>
<p>从<strong>客户端读写访问的透明度</strong>来看，数据复制集群系统分下面两种:</p>
<ol>
<li><strong>写主(WriteMaster)</strong> ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下 客户端需要对读与写进行区别，俗称读写分离。</li>
<li>**写任意(Write Any)**：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角 色与变化透明。</li>
</ol>
<p>对 zookeeper 来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而 写，随着机器的增多吞吐能力肯定下降(这也是它建立 observer 的原因)，而响应能力则取决于具体实现方 式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<h2 id="Zooke-eper-工作原理"><a href="#Zooke-eper-工作原理" class="headerlink" title="Zooke**eper 工作原理"></a>Zooke**<strong>eper 工作原理</strong></h2><p>Zookeeper 的<strong>核心是原子广播</strong>，这个机制<strong>保证了各个 Server 之间的同步</strong>。实现这个机制的协议叫做 <strong>Zab 协议</strong>。Zab 协议有两种模式，它们分别是**恢复模式(选主)<strong>和</strong>广播模式(同步)**。当服务启动或者在领导者崩溃 后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复 模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p>
<h2 id="ZooKeeper-的监听原理是什么？"><a href="#ZooKeeper-的监听原理是什么？" class="headerlink" title="ZooKeeper 的监听原理是什么？**"></a>ZooKeeper 的监听原理是什么？**</h2><p>在应用程序中，mian()方法首先会创建 zkClient，创建 zkClient 的同时就会产生两个进程，即Listener 进程（监听进程）和connect 进程（网络连接&#x2F;传输进程），当zkClient 调用getChildren()等方法注册监视器时，connect 进程向 ZooKeeper 注册监听器，注册后的监听器位于ZooKeeper 的监听器列表中，监听器列表中记录了 zkClient 的 IP，端口号以及要监控的路径，一旦目标文件发生变化，ZooKeeper 就会把这条消息发送给对应的zkClient 的Listener()进程，Listener 进程接收到后，就会执行 process()方法，在 process()方法中针对发生的事件进行处理。</p>
<h2 id="zookeeper-是如何保证事务的顺序一致性-的"><a href="#zookeeper-是如何保证事务的顺序一致性-的" class="headerlink" title="zookeeper 是如何保证事务的顺序一致性 的?**"></a>zookeeper 是如何保证事务的顺序一致性 的?**</h2><p>zookeeper 采用了<strong>递增的事务 Id 来标识</strong>，所有的 proposal(提议)都在被提出的时候加上了 zxid，<strong>zxid 实际 上是一个 64位的数字</strong>，<strong>高 32 位是 epoch(时期; 纪元; 世; 新时代)用来标识 leader 是否发生改变</strong>，如果有 新的 leader 产生出来，epoch 会自增，<strong>低 32 位用来递增计数</strong>。当新产生 proposal 的时候，会依据数据库的 两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就 会开始执行。</p>
<h2 id="分布式集群中为什么会有Master？"><a href="#分布式集群中为什么会有Master？" class="headerlink" title="分布式集群中为什么会有Master？**"></a>分布式集群中为什么会有Master？**</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行leader选举。</p>
<h2 id="Zookeeper-下-Server-工作状态"><a href="#Zookeeper-下-Server-工作状态" class="headerlink" title="Zookeeper 下 Server 工作状态**"></a>Zookeeper 下 Server 工作状态**</h2><p>服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。</p>
<ul>
<li><strong>LOOKING</strong>：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</li>
<li><strong>FOLLOWING</strong>：跟随者状态。表明当前服务器角色是Follower。</li>
<li><strong>LEADING</strong>：领导者状态。表明当前服务器角色是Leader。</li>
<li><strong>OBSERVING</strong>：观察者状态。表明当前服务器角色是Observer。</li>
</ul>
<h2 id="zookeeper-是如何选取主-leader-的"><a href="#zookeeper-是如何选取主-leader-的" class="headerlink" title="zookeeper 是如何选取主 leader 的?**"></a>zookeeper 是如何选取主 leader 的?**</h2><p>当 leader 崩溃或者 leader 失去大多数的 follower，这时 zk 进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的 Server 都恢复到一个正确的状态。Zk 的选举算法有两种:一种是基于 basic paxos 实现 的，另外一种是基于 fast paxos 算法实现的。<strong>系统默认的选举算法为 fast paxos</strong>。</p>
<p><strong>1、Zookeeper 选主流程(basic paxos)</strong></p>
<ol>
<li><p>选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server;</p>
</li>
<li><p>选举线程首先向所有 Server 发起一次询问(包括自己);</p>
</li>
<li><p>选举线程收到回复后，验证是否是自己发起的询问(验证 zxid 是否一致)，然后获取对方的 id(myid)，并存 储到当前询问对象列表中，最后获取对方提议的 leader 相关信息(id,zxid)，并将这些信息存储到当次选举的投 票记录表中;</p>
</li>
<li><p>收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次 要投票的 Server;</p>
</li>
<li><p>线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server 获得 n&#x2F;2 + 1 的 Server 票数，设置当前推荐的 leader 为获胜的 Server，将根据获胜的 Server 相关信息设置自己的状 态，否则，继续这个过程，直到 leader 被选举出来。通过流程分析我们可以得出:要使 Leader 获得多数Server 的支持，则 Server 总数必须是奇数 2n+1，且存活的 Server 的数目不得少于 n+1. 每个 Server 启动后 都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p>
</li>
</ol>
<p><img src="/../../assets/tBHRLMI5DFlnb7h.webp"></p>
<p><strong>2、Zookeeper 选主流程(basic paxos)</strong></p>
<p>fast paxos 流程是在选举过程中，某 Server 首先向所有 Server 提议自己要成为 leader，当其它 Server 收到提 议以后，解决 epoch 和 zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出 Leader。</p>
<p><img src="/../../assets/O8FWEKLPCZdGp6N.webp"></p>
<h2 id="Zookeeper-同步流程"><a href="#Zookeeper-同步流程" class="headerlink" title="Zookeeper 同步流程**"></a>Zookeeper 同步流程**</h2><p>选完 Leader 以后，zk 就进入状态同步过程。</p>
<ol>
<li>Leader 等待 server 连接;</li>
<li>Follower 连接 leader，将最大的 zxid 发送给 leader;</li>
<li>Leader 根据 follower 的 zxid 确定同步点;</li>
<li>完成同步后通知 follower 已经成为 uptodate 状态;</li>
<li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</li>
</ol>
<p><img src="/../../assets/PMLdtghm9CrSsfa.webp"></p>
<h2 id="分布式通知和协调"><a href="#分布式通知和协调" class="headerlink" title="分布式通知和协调**"></a>分布式通知和协调**</h2><p>对于系统调度来说:操作人员发送通知实际是通过控制台改变某个节点的状态，然后 zk 将这些变化发送给注册 了这个节点的 watcher 的所有客户端。对于执行情况汇报:每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进 程可以监控目录子节点的变化获得工作进度的实时的全局情况。</p>
<h2 id="机器中为什么会有-leader"><a href="#机器中为什么会有-leader" class="headerlink" title="机器中为什么会有 leader?**"></a>机器中为什么会有 leader?**</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可 以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p>
<h2 id="zk-节点宕机如何处理"><a href="#zk-节点宕机如何处理" class="headerlink" title="zk 节点宕机如何处理?**"></a>zk 节点宕机如何处理?**</h2><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他 节点会继续提供服务。</p>
<p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不 会丢失;</p>
<p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p>
<p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK 节点挂得太多，只剩一半或不 到一半节点能工作，集群才失效。<br>所以：</p>
<ul>
<li>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)</li>
<li>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1)</li>
</ul>
<h2 id="zookeeper-负载均衡和-nginx-负载均衡-区别"><a href="#zookeeper-负载均衡和-nginx-负载均衡-区别" class="headerlink" title="zookeeper 负载均衡和 nginx 负载均衡 区别**"></a>zookeeper 负载均衡和 nginx 负载均衡 区别**</h2><p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件;但是 nginx 的吞吐量比zk 大很多，应该说按业务选择用哪种方式。</p>
<h2 id="Zookeeper有哪几种几种部署模式？"><a href="#Zookeeper有哪几种几种部署模式？" class="headerlink" title="Zookeeper有哪几种几种部署模式？**"></a>Zookeeper有哪几种几种部署模式？**</h2><p>部署模式：单机模式、伪集群模式、集群模式。</p>
<h2 id="集群最少要几台机器，集群规则是怎样的"><a href="#集群最少要几台机器，集群规则是怎样的" class="headerlink" title="集群最少要几台机器，集群规则是怎样的?**"></a>集群最少要几台机器，集群规则是怎样的?**</h2><p>集群规则为2N+1台，N&gt;0，即3台。</p>
<p><strong>31、集群如果有3台机器，挂掉一台集群还能工作吗？****挂掉两台呢？</strong></p>
<p>记住一个原则：过半存活即可用。</p>
<h2 id="集群支持动态添加机器吗？"><a href="#集群支持动态添加机器吗？" class="headerlink" title="集群支持动态添加机器吗？**"></a>集群支持动态添加机器吗？**</h2><p>其实就是水平扩容了，Zookeeper在这方面不太好。两种方式：</p>
<ul>
<li>全部重启：关闭所有Zookeeper服务，修改配置之后启动。不影响之前客户端的会话。</li>
<li>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。</li>
</ul>
<p>3.5版本开始支持动态扩容。</p>
<h2 id="Zookeeper对节点的watch监听通知是永久的吗？-为什么不是永久的"><a href="#Zookeeper对节点的watch监听通知是永久的吗？-为什么不是永久的" class="headerlink" title="Zookeeper对节点的watch监听通知是永久的吗？**为什么不是永久的?"></a>Zookeeper对节点的watch监听通知是永久的吗？**<strong>为什么不是永久的?</strong></h2><p>不是。官方声明：一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。</p>
<p>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。<br>一般是客户端执行getData(“&#x2F;节点A”,true)，如果节点A发生了变更或删除，客户端会得到它的watch事件，但是在之后节点A又发生了变更，而客户端又没有设置watch事件，就不再给客户端发送。</p>
<p>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</p>
<h2 id="ZAB协议是什么？"><a href="#ZAB协议是什么？" class="headerlink" title="ZAB协议是什么？**"></a>ZAB协议是什么？**</h2><p>ZAB协议是一种专门为zookeeper设计的一种支持崩溃回复的原子广播协议，是一种通用的分布式一致性算法，基于该协议，zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体来说，zookeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更为以事务的形式广播到所有的副本进程上去，该协议的这个主备模式架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更。</p>
<p>简言之，该协议核心就是定义了对于那些会改变zookeeper服务器数据状态的事务请求的处理方式，所有事务请求都必须由一个全局唯一的服务器来协调处理，即leader服务器。</p>
<h2 id="Zookeeper的典型应用场景"><a href="#Zookeeper的典型应用场景" class="headerlink" title="Zookeeper的典型应用场景**"></a>Zookeeper的典型应用场景**</h2><p>Zookeeper是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。</p>
<p>通过对Zookeeper中丰富的数据节点进行交叉使用，配合Watcher事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：</p>
<ul>
<li>数据发布&#x2F;订阅</li>
<li>负载均衡</li>
<li>命名服务</li>
<li>分布式协调&#x2F;通知</li>
<li>集群管理</li>
<li>Master选举</li>
<li>分布式锁</li>
<li>分布式队列</li>
</ul>
<h3 id="1-数据发布-x2F-订阅"><a href="#1-数据发布-x2F-订阅" class="headerlink" title="1. 数据发布&#x2F;订阅"></a>1. 数据发布&#x2F;订阅</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>数据发布&#x2F;订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>动态获取数据（配置信息）</li>
<li>实现数据（配置信息）的集中式管理和数据的动态更新</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>Push 模式</li>
<li>Pull 模式</li>
</ul>
<h3 id="数据（配置信息）特性："><a href="#数据（配置信息）特性：" class="headerlink" title="数据（配置信息）特性："></a>数据（配置信息）特性：</h3><ul>
<li>数据量通常比较小</li>
<li>数据内容在运行时会发生动态更新</li>
<li>集群中各机器共享，配置一致</li>
</ul>
<p>如：机器列表信息、运行时开关配置、数据库配置信息等</p>
<h3 id="基于Zookeeper的实现方式"><a href="#基于Zookeeper的实现方式" class="headerlink" title="基于Zookeeper的实现方式"></a>基于Zookeeper的实现方式</h3><ol>
<li>数据存储：将数据（配置信息）存储到Zookeeper上的一个数据节点</li>
<li>数据获取：应用在启动初始化节点从Zookeeper数据节点读取数据，并在该节点上注册一个数据变更Watcher</li>
<li>数据变更：当变更数据时，更新Zookeeper对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。</li>
</ol>
<h3 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. 负载均衡</h3><p><strong>zk的命名服务</strong></p>
<p>命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p>
<p><strong>分布式通知和协调</strong></p>
<p>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。<br>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。</p>
<p><strong>zk的命名服****务（文件系统）</strong></p>
<p>命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p>
<p><strong>zk的配置管理（文件系统、通知机制）</strong></p>
<p>程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</p>
<p><strong>Zookeeper集群管理（文件系统、通知机制）</strong></p>
<p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。<br>对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。<br>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p>
<p><strong>Zookeeper分布式锁（文件系统、通知机制）</strong></p>
<p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p>
<p>对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 &#x2F;distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。</p>
<p>对于第二类， &#x2F;distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p>
<p><strong>Zookeeper队列管理（文件系统、通知机制）</strong></p>
<p>两种类型的队列：</p>
<ul>
<li>同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</li>
<li>队列按照 FIFO 方式进行入队和出队操作。</li>
</ul>
<p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p>
<p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</p>
<p><strong>Zookeeper获取分布式锁流程</strong></p>
<p>见下题。</p>
<p>**<br>**</p>
<p><strong>36、Zookeeper是如何实现分布式锁的?</strong></p>
<p><strong>基于Zookeeper的分布式锁都是依赖于zk节点路径唯一的机制来实现的.</strong></p>
<p>什么意思呢?</p>
<p>就是在zk中,在分布式锁的场景下 对于同一个路径,只能有一个客户端能创建成功,其它的都创建失败.(这个不难理解,在平时系统中也没见过有哪2个文件地址完全相同)</p>
<p>下面就说一下zk分布式锁2种实现,没错 本篇就是干的不能再干的干货!!!</p>
<h3 id="第一种分布式锁"><a href="#第一种分布式锁" class="headerlink" title="第一种分布式锁"></a>第一种分布式锁</h3><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><p>第一种实现是利用的zk的临时节点, 在争抢锁的时候,所有的客户端都尝试创建一个临时节点(代表锁住的资源),只有一个客户端会创建成功,创建成功的客户端得到锁,其它的客户端则监听(利用zk的watch)该节点的状态改变并且进入阻塞,节点改变后 zk server 会通知剩下的客户端,剩下的客户端停止阻塞并且重新争抢锁.</p>
<p>zk中有持久节点和临时节点,为什么使用临时节点呢?</p>
<p>如果使用的是持久节点,则这个节点在客户端下线后,依旧会一直存在,不会自动删除,导致 <code>其它客户端一直无法争抢到锁</code> .如果使用的是临时节点的话, <code>在客户端下线后zk会删除与其相关的临时节点,这样其它客户端就能重新争抢锁</code> .</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取不到锁，阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span> (!tryLock()) &#123;</span><br><span class="line">            <span class="comment">// 没获得锁，阻塞自己</span></span><br><span class="line">            waitForLock();</span><br><span class="line">            <span class="comment">// 再次尝试</span></span><br><span class="line">            lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123; <span class="comment">// 不会阻塞</span></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 创建临时节点,zk中的节点(路径)唯一,只有一个会创建成功</span></span><br><span class="line">      <span class="comment">// 为什么使用临时节点: 客户端掉线后会自动删除节点(释放锁)</span></span><br><span class="line">            client.createEphemeral(lockPath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *争抢不到锁的话,等待锁的释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">waitForLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">IZkDataListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IZkDataListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到节点被删除的消息,停止等待,重新争夺锁&quot;</span>);</span><br><span class="line">                cdl.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataChange</span><span class="params">(String dataPath, Object data)</span></span><br><span class="line">                    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听</span></span><br><span class="line">        client.subscribeDataChanges(lockPath, listener);</span><br><span class="line">        <span class="comment">// 判断锁节点是否存在，存在的话表明有别人</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.client.exists(lockPath)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待接收到消息后,继续往下执行</span></span><br><span class="line">                cdl.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消监听消息</span></span><br><span class="line">        client.unsubscribeDataChanges(lockPath, listener);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>实现简单,但是会有 <code>羊群效应</code> ,节点的删除都会通知所有的客户端,并且所有的客户端会 <code>取消监听 + 重新一起争夺锁 + 争夺失败 + 再次开启监听</code> ,如此循环,资源耗费多,并且这种耗费是可以避免的,那么如何避免呢?就是下面第二种的 <code>改进版分布式锁</code> .</p>
<h3 id="第二种分布式锁"><a href="#第二种分布式锁" class="headerlink" title="第二种分布式锁"></a>第二种分布式锁</h3><p>这一种分布式锁的实现是利用zk的临时顺序节点,每一个客户端在争夺锁的时候都由zk分配一个顺序号(sequence),客户端则按照这个顺序去获取锁.</p>
<p>具体流程</p>
<p>lock跟前面的一样,不过lockPath(锁住的资源)是一个持久节点,客户端在该持久节点下面创建临时顺序节点,获取到顺序号后,根据自己是否是最小的顺序号来获取锁,顺序号最小则获取锁,序号不为最小则监听(watch)前一个顺序号,当前一个顺序号被删除的时候表明锁被释放了,则会通知下一个客户端.</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面贴出跟第一种实现不同的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试加锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建临时顺序节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.currentPath == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在lockPath节点下面创建临时顺序节点</span></span><br><span class="line">            currentPath = <span class="built_in">this</span>.client.createEphemeralSequential(LockPath + <span class="string">&quot;/&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得所有的子节点</span></span><br><span class="line">        List&lt;String&gt; children = <span class="built_in">this</span>.client.getChildren(LockPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序list</span></span><br><span class="line">        Collections.sort(children);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前节点是否是最小的,如果是最小的节点,则表明此这个client可以获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (currentPath.equals(LockPath + <span class="string">&quot;/&quot;</span> + children.get(<span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是当前最小的sequence,取到前一个临时节点</span></span><br><span class="line">            <span class="comment">// 1.单独获取临时节点的顺序号</span></span><br><span class="line">            <span class="comment">// 2.查找这个顺序号在children中的下标</span></span><br><span class="line">            <span class="comment">// 3.存储前一个节点的完整路径</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curIndex</span> <span class="operator">=</span> children.indexOf(currentPath.substring(LockPath.length() + <span class="number">1</span>));</span><br><span class="line">            beforePath = LockPath + <span class="string">&quot;/&quot;</span> + children.get(curIndex - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">waitForLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 注册watcher</span></span><br><span class="line">        <span class="type">IZkDataListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IZkDataListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;监听到前一个节点被删除了&quot;</span>);</span><br><span class="line">                cdl.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听前一个临时节点</span></span><br><span class="line">        client.subscribeDataChanges(<span class="built_in">this</span>.beforePath, listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前一个节点还存在,则阻塞自己</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.client.exists(<span class="built_in">this</span>.beforePath)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 直至前一个节点释放锁,才会继续往下执行</span></span><br><span class="line">                cdl.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 醒来后,表明前一个临时节点已经被删除,此时客户端可以获取锁 &amp;&amp; 取消watcher监听</span></span><br><span class="line">        client.unsubscribeDataChanges(<span class="built_in">this</span>.beforePath, listener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><p>实现比第一种复杂一点,但是更加的合理,少做了很多不必要的操作,只唤醒了后面一个客户端.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由zk自身的设计,zk不适合高并发写,需要在使用zk分布式锁前先做一定过滤操作,先过滤掉部分请求,再进行锁争夺.</p>
<p>分布式锁当然不止zk的实现,各个实现都有其适用的场景,在分布式系统中,没有最完美的方案,只有最合适的方案,往往都是取舍问题.</p>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanqiu5ge/p/9405601.html">https://www.cnblogs.com/lanqiu5ge/p/9405601.html</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Java工程师面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/9023/" rel="prev" title="Java工程师面试题-web开发-其他">
                  <i class="fa fa-angle-left"></i> Java工程师面试题-web开发-其他
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/3cfb/" rel="next" title="Java工程师面试题-web开发-Dubbo">
                  Java工程师面试题-web开发-Dubbo <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhangxin</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:53</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
