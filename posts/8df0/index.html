  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zxblog.eu.org","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java工程师面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="Java工程师面试题-中间件-Kafka">
<meta property="og:url" content="https://zxblog.eu.org/posts/8df0/index.html">
<meta property="og:site_name" content="知行博客">
<meta property="og:description" content="Java工程师面试题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-16T08:50:09.000Z">
<meta property="article:modified_time" content="2024-08-18T10:14:29.250Z">
<meta property="article:author" content="zhangxin">
<meta property="article:tag" content="Java工程师面试题">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zxblog.eu.org/posts/8df0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zxblog.eu.org/posts/8df0/","path":"posts/8df0/","title":"Java工程师面试题-中间件-Kafka"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java工程师面试题-中间件-Kafka | 知行博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">知行博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">新站点：zxalive.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-kafka%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">1、为什么要使用 kafka，为什么要使用消息队列？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Kafka%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">2、Kafka的常用组件有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BA%8B%E7%89%A9%E5%AE%9A%E4%B9%89%E6%9C%89%E5%93%AA%E4%B8%89%E7%A7%8D"><span class="nav-number">3.</span> <span class="nav-text">3、数据传输的事物定义有哪三种?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81ZooKeeper%E5%9C%A8Kafka%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">4、ZooKeeper在Kafka中的作用是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%B2%A1%E6%9C%89ZooKeeper%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Kafka%E5%90%97%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">5、没有ZooKeeper可以使用Kafka吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81Kafka-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E8%BF%98%E6%B4%BB%E7%9D%80%E6%9C%89%E9%82%A3%E4%B8%A4%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">6、Kafka 判断一个节点是否还活着有那两个条件?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E8%A7%A3%E9%87%8A%E5%81%8F%E7%A7%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="nav-number">7.</span> <span class="nav-text">7、解释偏移的作用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81producer-%E6%98%AF%E5%90%A6%E7%9B%B4%E6%8E%A5%E5%B0%86%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%88%B0-broker-%E7%9A%84-leader-%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">8、producer 是否直接将数据发送到 broker 的 leader(主节点)?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81Kafa-consumer-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%B6%88%E8%B4%B9%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E6%B6%88%E6%81%AF"><span class="nav-number">9.</span> <span class="nav-text">9、Kafa consumer 是否可以消费指定分区消息?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A1%AC%E7%9B%98%E4%B8%8A%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">10.</span> <span class="nav-text">Kafka 存储在硬盘上的消息格式是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka-follower%E5%A6%82%E4%BD%95%E4%B8%8Eleader%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">kafka follower如何与leader同步数据？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E9%AB%98%E6%95%88%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E7%89%B9%E7%82%B9"><span class="nav-number">12.</span> <span class="nav-text">Kafka 高效文件存储设计特点:**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">Kafka 与传统消息系统之间有三个关键区别**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">Kafka为什么那么快？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E4%B8%AA-broker-%E4%BC%9A%E4%BB%8E-isr%E4%B8%AD%E8%B8%A2%E5%87%BA%E5%8E%BB%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">什么情况下一个 broker 会从 isr中踢出去？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka-producer%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%89%93%E5%85%A5%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">kafka producer如何优化打入速度？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka-producer-%E6%89%93%E6%95%B0%E6%8D%AE%EF%BC%8Cack-%E4%B8%BA-0%EF%BC%8C-1%EF%BC%8C-1-%E7%9A%84%E6%97%B6%E5%80%99%E4%BB%A3%E8%A1%A8%E5%95%A5%EF%BC%88ack%E6%9C%BA%E5%88%B6%EF%BC%89%EF%BC%8C-%E8%AE%BE%E7%BD%AE-1-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8Cleader-%E4%BC%9A%E8%AE%A4%E4%B8%BA%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF-commit%E4%BA%86%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">kafka producer 打数据，ack  为 0， 1， -1 的时候代表啥（ack机制）， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%98%AF%E5%90%A6%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">Kafka中的消息是否会丢失和重复消费？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Kafka%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">为什么Kafka不支持读写分离？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%93%E7%8E%B0%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">Kafka中是怎么体现消息顺序性的？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%8F%90%E4%BA%A4%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%A7%BB%E6%97%B6%E6%8F%90%E4%BA%A4%E7%9A%84%E6%98%AF%E5%BD%93%E5%89%8D%E6%B6%88%E8%B4%B9%E5%88%B0%E7%9A%84%E6%9C%80%E6%96%B0%E6%B6%88%E6%81%AF%E7%9A%84offset%E8%BF%98%E6%98%AFoffset-1"><span class="nav-number">21.</span> <span class="nav-text">消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">kafka如何实现延迟队列？**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E3%80%81%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E3%80%81%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="nav-number">23.</span> <span class="nav-text">kafka怎么处理消息顺序、重复发送、重复消费、消息丢失</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">Kafka在什么情况下会出现消息丢失及解决方案？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E6%98%AFpull%EF%BC%9Fpush%EF%BC%9F%E4%BC%98%E5%8A%A3%E5%8A%BF%E5%88%86%E6%9E%90"><span class="nav-number">25.</span> <span class="nav-text">Kafka是pull？push？优劣势分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E4%B8%ADzk%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">26.</span> <span class="nav-text">Kafka中zk的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0kafka%E7%9A%84rebalance%E6%9C%BA%E5%88%B6"><span class="nav-number">27.</span> <span class="nav-text">简述kafka的rebalance机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E7%9A%84%E6%80%A7%E8%83%BD%E5%A5%BD%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="nav-number">28.</span> <span class="nav-text">Kafka的性能好在什么地方</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangxin</p>
  <div class="site-description" itemprop="description">新站点：zxalive.com</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">267</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


    </div>

    <div class="main-inner post posts-expand">

  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zxblog.eu.org/posts/8df0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知行博客">
      <meta itemprop="description" content="新站点：zxalive.com">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java工程师面试题-中间件-Kafka | 知行博客">
      <meta itemprop="description" content="Java工程师面试题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java工程师面试题-中间件-Kafka
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-16 16:50:09" itemprop="dateCreated datePublished" datetime="2022-08-16T16:50:09+08:00">2022-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 18:14:29" itemprop="dateModified" datetime="2024-08-18T18:14:29+08:00">2024-08-18</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

            <div class="post-description">Java工程师面试题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p><code>推荐先阅读</code>：<a href="/posts/b2c4">Java工程师面试题</a></p>
</blockquote>
<p>“你用过消息中间件吗？用过哪些？”</p>
<p>这是在面试过程中面试官必问的一个问题，但是我真的听过很多人说没用过，也有人说用过但也仅仅知道怎么调用，其他的问题一概不知，在消息中间件在项目中发挥着中流砥柱作用的今天，仅仅知道调用显然是不够的的了，为了能让乡亲们多点底气，今天为大家带来Kafka的高频面试题（kafka我用的比较多）。</p>
<h2 id="1、为什么要使用-kafka，为什么要使用消息队列？"><a href="#1、为什么要使用-kafka，为什么要使用消息队列？" class="headerlink" title="1、为什么要使用 kafka，为什么要使用消息队列？"></a>1、为什么要使用 kafka，为什么要使用消息队列？</h2><ul>
<li>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。</li>
<li>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。</li>
<li>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。</li>
<li>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</li>
<li>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</li>
</ul>
<h2 id="2、Kafka的常用组件有哪些？"><a href="#2、Kafka的常用组件有哪些？" class="headerlink" title="2、Kafka的常用组件有哪些？"></a>2、Kafka的常用组件有哪些？</h2><ul>
<li>producer：消息的生产者, 自己决定哪个 partions 中生产消息, 两种机制:hash 与 轮询。</li>
<li>consumer：通过 zookeeper 进行维护消费者偏移量, consumer有自己的消费组,不同组之间维护同一个 topic 数据,互不影响.相同组的不同 consumer消费同一个 topic,这个 topic相同的数据只被消费一次。</li>
<li>broker：broker 组成 kafka 集群的节点,之间没有主从关系, 依赖 zookeeper进行协调, broker 负责消息的读写与存储, 一个 broker可以管理读个</li>
<li>partionstopic：一类消息的总称&#x2F;消息队里, topic是由 partions组成, 一个 topic 由多台 server 里的 partions 组成。zookeeper 协调 kafka broker,存储元数据, consumer的 offset+ broker 信息 +topic信息+ partions信息partions 组成 topic 的单元, 每个 topic有副本(创建 topic 指定), 每个 partions 只能有有个 broker管理</li>
</ul>
<h2 id="3、数据传输的事物定义有哪三种"><a href="#3、数据传输的事物定义有哪三种" class="headerlink" title="3、数据传输的事物定义有哪三种?"></a>3、数据传输的事物定义有哪三种?</h2><p>数据传输的事务定义通常有以下三种级别：</p>
<ul>
<li>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输。</li>
<li>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输。</li>
<li>精确的一次(Exactly once): 不会漏传输也不会重复传输,每个消息都传输被一次而 且仅仅被传输一次，这是大家所期望的。</li>
</ul>
<h2 id="4、ZooKeeper在Kafka中的作用是什么？"><a href="#4、ZooKeeper在Kafka中的作用是什么？" class="headerlink" title="4、ZooKeeper在Kafka中的作用是什么？"></a>4、ZooKeeper在Kafka中的作用是什么？</h2><p>Apache Kafka是一个使用Zookeeper构建的分布式系统。虽然，Zookeeper的主要作用是在集群中的不同节点之间建立协调。但是，如果任何节点失败，我们还使用Zookeeper从先前提交的偏移量中恢复，因为它做周期性提交偏移量工作。</p>
<h2 id="5、没有ZooKeeper可以使用Kafka吗？"><a href="#5、没有ZooKeeper可以使用Kafka吗？" class="headerlink" title="5、没有ZooKeeper可以使用Kafka吗？"></a>5、没有ZooKeeper可以使用Kafka吗？</h2><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖。但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</p>
<h2 id="6、Kafka-判断一个节点是否还活着有那两个条件"><a href="#6、Kafka-判断一个节点是否还活着有那两个条件" class="headerlink" title="6、Kafka 判断一个节点是否还活着有那两个条件?"></a>6、Kafka 判断一个节点是否还活着有那两个条件?</h2><ul>
<li>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。</li>
<li>如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久。</li>
</ul>
<h2 id="7、解释偏移的作用。"><a href="#7、解释偏移的作用。" class="headerlink" title="7、解释偏移的作用。"></a>7、解释偏移的作用。</h2><p>给分区中的消息提供了一个顺序ID号，我们称之为偏移量。因此，为了唯一地识别分区中的每条消息，我们使用这些偏移量。</p>
<h2 id="8、producer-是否直接将数据发送到-broker-的-leader-主节点"><a href="#8、producer-是否直接将数据发送到-broker-的-leader-主节点" class="headerlink" title="8、producer 是否直接将数据发送到 broker 的 leader(主节点)?"></a>8、producer 是否直接将数据发送到 broker 的 leader(主节点)?</h2><p>producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了 帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标topic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了。</p>
<h2 id="9、Kafa-consumer-是否可以消费指定分区消息"><a href="#9、Kafa-consumer-是否可以消费指定分区消息" class="headerlink" title="9、Kafa consumer 是否可以消费指定分区消息?"></a>9、Kafa consumer 是否可以消费指定分区消息?</h2><p>Kafa consumer 消费消息时，向 broker 发出”fetch”请求去消费特定分区的消息，consumer指定消息在日志中的偏移量(offset)，就可以消费从这个位置开始的消息，customer 拥有 了 offset 的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的。</p>
<h2 id="Kafka-存储在硬盘上的消息格式是什么"><a href="#Kafka-存储在硬盘上的消息格式是什么" class="headerlink" title="Kafka 存储在硬盘上的消息格式是什么?"></a>Kafka 存储在硬盘上的消息格式是什么?</h2><p>消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32校验码。</p>
<ul>
<li>消息长度: 4 bytes (value: 1+4+n)</li>
<li>版本号: 1 byte</li>
<li>CRC 校验码: 4 bytes</li>
<li>具体的消息: n bytes</li>
</ul>
<h2 id="kafka-follower如何与leader同步数据？"><a href="#kafka-follower如何与leader同步数据？" class="headerlink" title="kafka follower如何与leader同步数据？"></a>kafka follower如何与leader同步数据？</h2><p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。</p>
<h2 id="Kafka-高效文件存储设计特点"><a href="#Kafka-高效文件存储设计特点" class="headerlink" title="Kafka 高效文件存储设计特点:**"></a>Kafka 高效文件存储设计特点:**</h2><ol>
<li><p>Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定 期清除或删除已经消费完文件，减少磁盘占用。</p>
</li>
<li><p>通过索引信息可以快速定位 message 和确定 response 的最大大小。</p>
</li>
<li><p>通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。</p>
</li>
<li><p>通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。</p>
</li>
</ol>
<h2 id="Kafka-与传统消息系统之间有三个关键区别"><a href="#Kafka-与传统消息系统之间有三个关键区别" class="headerlink" title="Kafka 与传统消息系统之间有三个关键区别**"></a>Kafka 与传统消息系统之间有三个关键区别**</h2><ul>
<li>Kafka 持久化日志，这些日志可以被重复读取和无限期保留</li>
<li>Kafka 是一个分布式系统:它以集群的方式运行，可以灵活伸缩，在内部通过复制数据 提升容错能力和高可用性</li>
<li>Kafka 支持实时的流式处理</li>
</ul>
<h2 id="Kafka为什么那么快？"><a href="#Kafka为什么那么快？" class="headerlink" title="Kafka为什么那么快？**"></a>Kafka为什么那么快？**</h2><ul>
<li>Cache Filesystem Cache PageCache缓存</li>
<li>顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。</li>
<li>Zero-copy 零拷技术减少拷贝次数</li>
<li>Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。</li>
<li>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。</li>
</ul>
<h2 id="什么情况下一个-broker-会从-isr中踢出去？"><a href="#什么情况下一个-broker-会从-isr中踢出去？" class="headerlink" title="什么情况下一个 broker 会从 isr中踢出去？**"></a>什么情况下一个 broker 会从 isr中踢出去？**</h2><p>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 。</p>
<h2 id="kafka-producer如何优化打入速度？"><a href="#kafka-producer如何优化打入速度？" class="headerlink" title="kafka producer如何优化打入速度？**"></a>kafka producer如何优化打入速度？**</h2><ul>
<li>增加线程</li>
<li>提高 batch.size</li>
<li>增加更多 producer 实例</li>
<li>增加 partition 数</li>
<li>设置 acks&#x3D;-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；</li>
<li>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</li>
</ul>
<h2 id="kafka-producer-打数据，ack-为-0，-1，-1-的时候代表啥（ack机制），-设置-1-的时候，什么情况下，leader-会认为一条消息-commit了？"><a href="#kafka-producer-打数据，ack-为-0，-1，-1-的时候代表啥（ack机制），-设置-1-的时候，什么情况下，leader-会认为一条消息-commit了？" class="headerlink" title="kafka producer 打数据，ack  为 0， 1， -1 的时候代表啥（ack机制）， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了？**"></a>kafka producer 打数据，ack  为 0， 1， -1 的时候代表啥（ack机制）， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了？**</h2><ul>
<li>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。</li>
<li>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li>
<li>-1 producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。</li>
</ul>
<h2 id="Kafka中的消息是否会丢失和重复消费？"><a href="#Kafka中的消息是否会丢失和重复消费？" class="headerlink" title="Kafka中的消息是否会丢失和重复消费？**"></a>Kafka中的消息是否会丢失和重复消费？**</h2><p>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：<strong>消息发送和消息消费</strong>。</p>
<p><strong>1、消息发送</strong></p>
<pre><code> **Kafka消息发送有两种方式：****同步（sync）和异步（async）**，默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：
</code></pre>
<ul>
<li>0—表示不进行消息接收是否成功的确认；</li>
<li>1—表示当Leader接收成功时确认；</li>
<li>-1—表示Leader和Follower都接收成功时确认；</li>
</ul>
<p>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景：</p>
<p>（1）acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失；</p>
<p>（2）acks&#x3D;1、同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；</p>
<p><strong>2、消息消费</strong></p>
<p><strong>Kafka消息消费有两个consumer接口，Low-level API和High-level API</strong>：</p>
<ul>
<li>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；</li>
<li>High-level API：封装了对parition和offset的管理，使用简单；</li>
</ul>
<p>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来、并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“诡异”的消失了；</p>
<p><strong>解决办法</strong>：</p>
<ul>
<li><p>针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态；</p>
</li>
<li><p>针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。</p>
<p>消息重复消费及解决参考：<a target="_blank" rel="noopener" href="https://www.javazhiyin.com/22910.html">https://www.javazhiyin.com/22910.html</a></p>
</li>
</ul>
<h2 id="为什么Kafka不支持读写分离？"><a href="#为什么Kafka不支持读写分离？" class="headerlink" title="为什么Kafka不支持读写分离？**"></a>为什么Kafka不支持读写分离？**</h2><p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。</p>
<p>Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</p>
<ol>
<li>数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。</li>
<li>延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</li>
</ol>
<h2 id="Kafka中是怎么体现消息顺序性的？"><a href="#Kafka中是怎么体现消息顺序性的？" class="headerlink" title="Kafka中是怎么体现消息顺序性的？**"></a>Kafka中是怎么体现消息顺序性的？**</h2><p>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。</p>
<p>整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.</p>
<h2 id="消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1"><a href="#消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1" class="headerlink" title="消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?**"></a>消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?**</h2><p>offset+1</p>
<h2 id="kafka如何实现延迟队列？"><a href="#kafka如何实现延迟队列？" class="headerlink" title="kafka如何实现延迟队列？**"></a>kafka如何实现延迟队列？**</h2><p>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。</p>
<p>底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask.</p>
<p>Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</p>
<blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/80697456">https://blog.csdn.net/u013256816/article/details/80697456</a></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28900249/article/details/90346599">https://blog.csdn.net/qq_28900249/article/details/90346599</a></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kx33389/p/11182082.html">https://www.cnblogs.com/kx33389/p/11182082.html</a></p>
</blockquote>
<h2 id="kafka怎么处理消息顺序、重复发送、重复消费、消息丢失"><a href="#kafka怎么处理消息顺序、重复发送、重复消费、消息丢失" class="headerlink" title="kafka怎么处理消息顺序、重复发送、重复消费、消息丢失"></a>kafka怎么处理消息顺序、重复发送、重复消费、消息丢失</h2><h2 id="Kafka在什么情况下会出现消息丢失及解决方案？"><a href="#Kafka在什么情况下会出现消息丢失及解决方案？" class="headerlink" title="Kafka在什么情况下会出现消息丢失及解决方案？"></a>Kafka在什么情况下会出现消息丢失及解决方案？</h2><ol>
<li><p>消息发送</p>
<blockquote>
<ol>
<li>ack&#x3D;0，不重试<br>producer发送消息完，不管结果了，如果发送失败也就丢失了。</li>
<li>ack&#x3D;1，leader crash<br>producer发送消息完，只等待lead写入成功就返回了，leader crash了，这时follower没来及同步，消 息丢失。</li>
<li>unclean.leader.election.enable 配置true<br>允许选举ISR以外的副本作为leader,会导致数据丢失，默认为false。producer发送异步消息完，只等待 lead写入成功就返回了，leader crash了，这时ISR中没有follower，leader从OSR中选举，因为OSR 中本来落后于Leader造成消息丢失。</li>
</ol>
<p>解决方案：</p>
<ol>
<li><p>配置：ack&#x3D;all &#x2F; -1,tries &gt; 1,unclean.leader.election.enable : false producer发送消息完，等待follower同步完再返回，如果异常则重试。副本的数量可能影响吞吐量。</p>
<p>不允许选举ISR以外的副本作为leader。</p>
</li>
<li><p>配置：min.insync.replicas &gt; 1</p>
<p>副本指定必须确认写操作成功的最小副本数量。如果不能满足这个最小值，则生产者将引发一个异常(要么是 NotEnoughReplicas，要么是NotEnoughReplicasAfterAppend)。<br>min.insync.replicas和ack更大的持久性保证。确保如果大多数副本没有收到写操作，则生产者将引发异 常。</p>
</li>
<li><p>失败的offset单独记录<br>producer发送消息，会自动重试，遇到不可恢复异常会抛出，这时可以捕获异常记录到数据库或缓存，进行 单独处理。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>消费</p>
<p>先commit再处理消息。如果在处理消息的时候异常了，但是offset 已经提交了，这条消息对于该消费者来 说就是丢失了，再也不会消费到了。</p>
</li>
<li><p>broker的刷盘</p>
<p>减小刷盘间隔</p>
</li>
</ol>
<h2 id="Kafka是pull？push？优劣势分析"><a href="#Kafka是pull？push？优劣势分析" class="headerlink" title="Kafka是pull？push？优劣势分析"></a>Kafka是pull？push？优劣势分析</h2><p>pull模式：</p>
<ul>
<li>根据consumer的消费能力进行数据拉取，可以控制速率</li>
<li>可以批量拉取、也可以单条拉取</li>
<li>可以设置不同的提交方式，实现不同的传输语义</li>
</ul>
<blockquote>
<p>缺点：如果kafka没有数据，会导致consumer空循环，消耗资源</p>
<p>解决：通过参数设置，consumer拉取数据为空或者没有达到一定数量时进行阻塞</p>
</blockquote>
<p>push模式：不会导致consumer循环等待</p>
<blockquote>
<p>优点：不会导致consumer循环等待</p>
<p>缺点：速率固定、忽略了consumer的消费能力，可能导致拒绝服务或者网络拥塞等情况</p>
</blockquote>
<h2 id="Kafka中zk的作用"><a href="#Kafka中zk的作用" class="headerlink" title="Kafka中zk的作用"></a>Kafka中zk的作用</h2><p>&#x2F;brokers&#x2F;ids：临时节点，保存所有broker节点信息，存储broker的物理地址、版本信息、启动时间 等，节点名称为brokerID，broker定时发送心跳到zk，如果断开则该brokerID会被删除</p>
<p>&#x2F;brokers&#x2F;topics：临时节点，节点保存broker节点下所有的topic信息，每一个topic节点下包含一个固 定的partitions节点，partitions的子节点就是topic的分区，每个分区下保存一个state节点、保存着当 前leader分区和ISR的brokerID，state节点由leader创建，若leader宕机该节点会被删除，直到有新的 leader选举产生、重新生成state节点</p>
<p>&#x2F;consumers&#x2F;[group_id]&#x2F;owners&#x2F;[topic]&#x2F;[broker_id-partition_id]：维护消费者和分区的注册关系</p>
<p>&#x2F;consumers&#x2F;[group_id]&#x2F;offsets&#x2F;[topic]&#x2F;[broker_id-partition_id]：分区消息的消费进度Offset</p>
<p>client通过topic找到topic树下的state节点、获取leader的brokerID，到broker树中找到broker的物理 地址，但是client不会直连zk，而是通过配置的broker获取到zk中的信息</p>
<h2 id="简述kafka的rebalance机制"><a href="#简述kafka的rebalance机制" class="headerlink" title="简述kafka的rebalance机制"></a>简述kafka的rebalance机制</h2><p>consumer group中的消费者与topic下的partion重新匹配的过程</p>
<p>何时会产生rebalance：</p>
<ul>
<li>consumer group中的成员个数发生变化</li>
<li>consumer消费超时</li>
<li>group订阅的topic个数发生变化</li>
<li>group订阅的topic的分区数发生变化</li>
</ul>
<p>coordinator：通常是partition的leader节点所在的broker，负责监控group中consumer的存活， consumer维持到coordinator的心跳，判断consumer的消费超时</p>
<ul>
<li>coordinator通过心跳返回通知consumer进行rebalance</li>
<li>consumer请求coordinator加入组，coordinator选举产生leader consumer</li>
<li>leader consumer从coordinator获取所有的consumer，发送syncGroup(分配信息)给到 coordinator</li>
<li>coordinator通过心跳机制将syncGroup下发给consumer</li>
<li>完成rebalance</li>
</ul>
<p>leader consumer监控topic的变化，通知coordinator触发rebalance</p>
<p>如果C1消费消息超时，触发rebalance，重新分配后、该消息会被其他消费者消费，此时C1消费完成提 交offset、导致错误</p>
<p>解决：coordinator每次rebalance，会标记一个Generation给到consumer，每次rebalance该 Generation会+1，consumer提交offset时，coordinator会比对Generation，不一致则拒绝提交</p>
<h2 id="Kafka的性能好在什么地方"><a href="#Kafka的性能好在什么地方" class="headerlink" title="Kafka的性能好在什么地方"></a>Kafka的性能好在什么地方</h2><p>kafka不基于内存，而是硬盘存储，因此消息堆积能力更强</p>
<p>顺序写：利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的， 节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition物理上分为多个segment存储， 方便删除</p>
<p>传统：</p>
<ul>
<li>读取磁盘文件数据到内核缓冲区</li>
<li>将内核缓冲区的数据copy到用户缓冲区</li>
<li>将用户缓冲区的数据copy到socket的发送缓冲区</li>
<li>将socket发送缓冲区中的数据发送到网卡、进行传输</li>
</ul>
<p>零拷贝：</p>
<ul>
<li>直接将内核缓冲区的数据发送到网卡传输</li>
<li>使用的是操作系统的指令支持</li>
</ul>
<p>kafka不太依赖jvm，主要理由操作系统的pageCache，如果生产消费速率相当，则直接用pageCache 交换数据，不需要经过磁盘IO</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Java工程师面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/f2bf/" rel="prev" title="Java工程师面试题-中间件-搜索引擎">
                  <i class="fa fa-angle-left"></i> Java工程师面试题-中间件-搜索引擎
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/8295/" rel="next" title="Java工程师面试题-Netty">
                  Java工程师面试题-Netty <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





  <a target="_blank" rel="noopener" href="https://zxalive.com" class="special-link">新站点zxalive.com</a>


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhangxin</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:53</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
